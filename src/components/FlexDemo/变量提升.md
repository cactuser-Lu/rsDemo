# JS

## 变量提升

变量提升即将变量声明提升到它所在作用域的最开始的部分

**函数提升优先级高于变量提升，且不会被同名变量声明时覆盖，但是会被同名变量赋值后覆盖**

·var的创建和初始化被提升，赋值不会被提升。

·let的创建被提升，初始化和赋值不会被提升。let 和 const 作用基本一致，但是const 声明的变量不能再次赋值

·function的创建、初始化和赋值均会被提升

```javascript
console.log(typeof a)
function a() {} 
console.log(typeof a)
var a = 1;
console.log(typeof a)

let myname= 'sxx'；

{

    console.log(myname)；

   let myname= 'sdx '；

}//报错
```



## 手写 call

**Function.prototype.call()**

call() 可以修改函数调用时 this 的指向，其余参数则会作为原函数的参数。

call 接收的参数：

1. 第一个参数 thisArg。代表 this 将会被指向的值。如果不是对象，也会通过 Object() 方法转换为对象。如果是 null 或 undefined，this 则会指向全局对象（即 window 或 global），或在严格模式（"use strict;"）下，保持 undefined 或 null；

2. 其余参数。第二个往后的参数则会传入到原函数中。

```javascript
Function.prototype.myCall=function(context){
  // context=context||window
  if(context==null||context==undefined)context=window
  else context=Object(context)
  const arg=[...arguments].slice(1)
  const fn=Symbol('fn')
  context.fn=this
  context.fn(...arg)
  delete context.fn
}
const name1='ddd'
const tom={name1:'kkk'}
function f1(){
  console.log(this.name1)
  console.log(arguments)
}
console.log(name1)
f1.myCall(tom,1,2,35,6)
```



## 箭头函数

##### 箭头函数不绑定this，会捕获其所在上下文的this，作为自己的this

> 这句话需要注意的是，箭头函数的外层如果有普通函数，那么箭头函数的this就是这个外层的普通函数的this，箭头函数的外层如果没有普通函数，那么箭头函数的this就是全局变量。

##### 箭头函数是匿名函数，不能作为构造函数，不可以使用new命令，否则后抛出错误

##### 使用call,apply,bind并不会改变箭头函数中的this指向。

- 当对箭头函数使用call或apply方法时，只会传入参数并调用函数，并不会改变箭头函数中this的指向。
- 当对箭头函数使用bind方法时，只会返回一个预设参数的新函数，并不会改变这个新函数的this指向。

##### 箭头函数没有原型对象prototype这个属性

## promise

**Promise.all()** 的这种行为被称为快速失败，如果 promise 数组中至少有一个 promise 被 rejected ，那么返回的 promise 也被拒绝。如果promise 数组中所有的都被 rejected ，那么返回的promise 被拒绝的原因是先rejected的那一个。

如果至少有一个 `promise` 被 `rejected` ，那么 `allPromise` 会以同样的原因立即 `rejected` （不等待其他 `promise` 的执行）。

```js
/*
    最终程序
*/
function myAll(...p) {
    return new Promise((resolve, reject) => {
        let index = 0
        const res = new Array(p.length)
        for(let i = 0; i < p.length; i++) {
            p[i].then(res => {
                res[i] = res
                index ++
                if(index === p.length) {
                    resolve(res)
                }
            }).catch(err => {
                reject(err)
            })
        }
    })
}

作者：康
链接：https://juejin.cn/post/6969767955420676133
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```



## 手写Promise.retry

实现 Promise.retry，成功后 resolve 结果，失败后重试，尝试超过一定次数才真正的 reject

```javascript
Promise.retry=function(fn,times,delay){
    let tryTime=0
    return new Promise((resolve,reject)=>{
        function attempt(){
            console.log(tryTime)
            fn().then(res=>{
               return resolve(res)
            }).catch(err=>{
                if(++tryTime<times){
                    setTimeout(attempt, delay);
                }
                else reject(err)
            })
        }
        attempt()
    })
}

function getUser() {
    return new Promise((resolve, reject) => {
        const result = Math.floor(Math.random() * 10)
        console.log('res',result)
        return result < 3 ? resolve({
            id: result,
            username: 'ming'
        }) : reject(new Error(`The ${result} is greater than 3`))
    })
}

Promise.retry(getUser, 5, 1000).then(r => {
    console.log(`The result is ${r.username}`)
})

```

## JS实现每隔一秒打印一个数字

```javascript
let tryTime=0
function attempt(){
    console.log(tryTime)
    if(++tryTime<5){
        setTimeout(attempt, 1000);
    }
    else return
}
attempt()
```

```javascript
for(let i=0;i<5;i++){
    setTimeout(() => {
        console.log(i)
    }, 1000*i);
}
```

## 讲一下async-await和generator的关系

### generator

thunk **多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数**

```js
// 正常版本的readFile（多参数版本）
fs.readFile(fileName, callback);
 
// Thunk版本的readFile（单参数版本）
var thunkFn = Thunk(filename);
thunkFn(cb) 
var Thunk = function(filename) {
    return function(cb) {
        return fs.readFile(fileName, cb)
    }
}
```

Generator 函数的执行过程，其实是将同一个回调函数，反复传入 next 方法的 value 属性。这使得我们可以用递归来自动完成这个过程。

```js
 
var g = gen();
var r1 = g.next();
r1.value(function(err, data){
  var r2 = g.next(data);
  r2.value(function(err, data){
    g.next(data);
  });
});

 
function run(fn) {
  var gen = fn();

  function next(err, data) {
    var result = gen.next(data);
    if (result.done) return;
    result.value(next);
  }
 
  next();
}
 
run(gen);
```



上面代码的 run 函数，就是一个 Generator 函数的自动执行器。内部的 next 函数就是 Thunk 的回调函数。 next 函数先将指针移到 Generator 函数的下一步（gen.next 方法），然后判断 Generator 函数是否结束（result.done 属性），如果没结束，就将 next 函数再传入 Thunk 函数（result.value 属性），否则就直接退出。

**co 函数库**

每次执行 generator 函数时自己写启动器比较麻烦。[co函数库](https://link.zhihu.com/?target=https%3A//github.com/tj/co) 是一个 generator 函数的自启动执行器，使用条件是 generator 函数的 yield 命令后面，只能是 thunk 函数或 Promise 对象，co 函数执行完返回一个 Promise 对象。

```js
// 做了简化，与源码基本一致
const co = (generator, ...rest) => {
  const ctx = this
  return new Promise((resolve, reject) => {
    const gen = generator.call(ctx, ...rest)
    if (!gen || typeof gen.next !== 'function') {
      return resolve(gen)
    } 
    
    const onFulfilled = res => {
      let ret
      try {
        ret = gen.next(res)
      } catch (e) {
        return reject(e)
      }
      next(ret)
    }    

    const onRejected = err => {
      let ret
      try {
        ret = gen.throw(err)
      } catch (e) {
        return reject(e)
      }
      next(ret)
    }

    const next = result => {
      if (result.done) {
        return resolve(result.value)
      }
      toPromise(result.value).then(onFulfilled, onRejected)
    }

    onFulfilled()
  })  
}

const toPromise = value => {
  if (isPromise(value)) return value
  if ('function' == typeof value) {
    return new Promise((resolve, reject) => {
      value((err, ...rest) => {
        if (err) {
          return reject(err)
        }
        resolve(rest.length > 1 ? rest : rest[0])
      })
    })
  }
}
```

一句话，async、await 是 co 库的官方实现。也可以看作自带启动器的 generator 函数的语法糖。不同的是，async、await 只支持 Promise 和原始类型的值，不支持 thunk 函数。

## Generator实现

 *生成器函数根据yield语句将代码分割为switch-case块，后续通过切换_context.prev和_context.next来分别执行各个case*

这段代码并不难理解，我们分析一下调用流程：

1. 我们定义的`function* `生成器函数被转化为以上代码
2. 转化后的代码分为三大块：
   - `gen$(_context)`由yield分割生成器函数代码而来
   - `context对象`用于储存函数执行上下文
   - `invoke()方法`定义next()，用于执行gen$(_context)来跳到下一步
3. 当我们调用`g.next()`，就相当于调用`invoke()方法`，执行`gen$(_context)`，进入switch语句，switch根据context的标识，执行对应的case块，return对应结果
4. 当生成器函数运行到末尾（没有下一个yield或已经return），switch匹配不到对应代码块，就会return空值，这时`g.next()`返回`{value: undefined, done: true}`

从中我们可以看出，**Generator实现的核心在于`上下文的保存`，函数并没有真的被挂起，每一次yield，其实都执行了一遍传入的生成器函数，只是在这个过程中间用了一个context对象储存上下文，使得每次执行生成器函数的时候，都可以从上一个执行结果开始执行，看起来就像函数被挂起了一样**



作者：写代码像蔡徐抻
链接：https://juejin.cn/post/6844904096525189128
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## no-cache 和 no-store

no-cache 是 Cache-control 的一个属性。它并不像字面意思一样禁止缓存，实际上，no-cache 的意思是强制进行协商缓存。如果某一资源的 Cache-control 中设置了 no-cache，那么该资源会直接跳过强缓存的校验，直接去服务器进行协商缓存。而 no-store 就是禁止所有的缓存策略了。
————————————————
版权声明：本文为CSDN博主「ZHANG.......」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zyf971020/article/details/127276291

## var 和 let 的区别

### 区别：

1.使用var声明的变量，其[作用域](https://so.csdn.net/so/search?q=作用域&spm=1001.2101.3001.7020)为该语句所在的函数内，且存在变量提升现象；
2.使用let声明的变量，其作用域为该语句所在的代码块内，不存在变量提升；
3.let不允许在相同作用域内，重复声明同一个变量。

```javascript
for(let i=0;i<5;i++){// i虽然在全局作用域声明，但是在for循环体局部作用域中使用的时候，变量会被固定，不受外界干扰。变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6
    setTimeout(() => {
        console.log(i)
    }, 1000*i);//  i 是循环体内局部作用域，不受外界影响。//  i只有在这里是可见的
}//0  1  2  3  4
//for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域
for(var i=0;i<5;i++){//变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。
    setTimeout(() => {// 同步注册回调函数到 异步的 宏任务队列。
        console.log(i) // 执行此代码时，同步代码for循环已经执行完成
    }, 1000*i);
    // i 对于for循环外的范围是可见的
}//5 5 5 5 5 
```

`let` 和 `const` 声明只有在运行期间被 JavaScript 引擎评估词法绑定（赋值）时才会被初始化。这意味着在此之前，你不能访问该变量。这就是我们所说的 “[暂时性死区](https://www.zhihu.com/search?q=暂时性死区&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2327801007})” （Temporal Dead Zone：TDZ），在变量创建和初始化之间的时间段，不能被访问。

## JS类型

​		一类是原始值类型，即number、boolean、null、undefined、string、symbol六种；另一类是引用类型，即对象、函数、数组三种。前者变量存储的就是值。后者变量持有的值实质是一个指针，并不是值本身，当我们调用引用类型变量时，是根据指针找到内存中实际对象所在的位置，然后根据那个位置再去拿到对应的值。[四基两空一对象](https://blog.csdn.net/qq_45253817/article/details/121795602#t0)

![栈内存与堆内存](https://img-blog.csdnimg.cn/69936ebc472448f3b8150dd9adb555fb.png#pic_center)

## 深拷贝和浅拷贝的区别

浅拷贝只复制对象的第一层属性，如果属性是引用类型（如对象、数组），则复制的是引用，而不是实际的值。

### 实现方式：

- **展开运算符 (`...`)**
- **`Object.assign`**

```javascript
const a = {
    name: 'hhvcg',
    old: 23
}
// 深拷贝  不仅会在栈中开辟另一块空间，若被拷贝对象中有引用类型，则还会在堆内存中开辟另一块空间存储引用类型的真实数据
const b = JSON.parse(JSON.stringify(a))
// 浅拷贝 slice() concat()
const c = a
//JSON.stingify(obj)将js中的对象转换成JSON字符串  JSON.parse()将json字符串解析成对象
b.name = '深拷贝'
console.log(a.name) //hhvcg(a不受影响)

c.name = '浅拷贝'
console.log(a.name) //浅拷贝(a也变化)
```

深拷贝会递归地复制对象的所有层级，生成一个全新的对象，嵌套对象也不会共享。

**`JSON.stringify` 和 `JSON.parse`**

**总而言之一句话，浅拷贝是地址，深拷贝完全复制**

`JSON.stringify` 是一种简单的深拷贝方法，但它有以下局限性：

### 1. **不支持函数**

### 2. **不支持 `undefined`**

### 3. **不支持特殊对象**   **`Date` 对象**  **`RegExp` 对象**

### 4. **不支持循环引用**

## Person最后通过其原型链指向的是啥

在JavaScript中，如果你有一个通过构造函数（比如`Person`）创建的实例对象（比如`person1`），那么该实例对象（`person1`）的原型链最终会指向`Object.prototype`。但是，当我们谈论`Person`构造函数本身（而不是其实例）时，情况就有所不同了。

`Person`构造函数（或任何JavaScript函数）实际上是一个函数对象，因此它自身也遵循原型链的规则。`Person`的原型链如下：

```js
复制代码
function Person(name, age) {  
    this.name = name;  
    this.age = age;  
    this.greet = function() {  
        console.log(`Hello, my name is ${this.name} and I am ${this.age} years old.`);  
    };  
}
var person1 = new Person('Alice', 30);  
person1 的prototype和Person的prototype分别是什么
Person -> Function.prototype -> Object.prototype -> null
```

这里解释一下每个部分的含义：

1. **`Person`**：这是你的构造函数，用于创建`Person`类型的实例。
2. **`Function.prototype`**：由于`Person`是一个函数，它的原型（`__proto__`或内部`[[Prototype]]`）指向`Function.prototype`。`Function.prototype`是所有函数对象的原型，它提供了所有函数对象共享的方法，比如`call()`、`apply()`和`bind()`等。
3. **`Object.prototype`**：`Function.prototype`本身也是一个对象，因此它也有自己的原型，即`Object.prototype`。这提供了所有对象（包括函数对象）都继承的默认方法和属性，比如`toString()`、`valueOf()`和`hasOwnProperty()`等。
4. **`null`**：`Object.prototype`的原型是`null`，这表示原型链的结束。

重要的是要理解，当你谈论`Person`的原型链时，你实际上是在谈论`Person`函数对象自身的原型链，而不是通过`Person`创建的实例（如`person1`）的原型链。实例的原型链会指向`Person.prototype`，然后才是`Object.prototype`。

总结：

- **`Person`的原型链**：`Person -> Function.prototype -> Object.prototype -> null`
- **`Person`实例（如`person1`）的原型链**：`person1 -> Person.prototype -> Object.prototype -> null`

## Number的精度丢失以及如何解决

在JavaScript中，`Number` 类型用于表示整数和浮点数，但使用浮点数时经常会遇到精度丢失的问题。这主要是因为JavaScript采用IEEE 754标准来表示数字，即双精度64位浮点数。这种表示方式无法精确表示所有小数，尤其是那些无限循环小数（如1/3或0.1），这会导致“舍入误差”。

```js
console.log(0.1 + 0.2); // 输出：0.30000000000000004，而不是0.3
```

1. **使用toFixed()方法**

如果你只是需要输出或者处理到一定的小数点后几位，可以使用`toFixed()`方法。但请注意，这会返回一个字符串。

2. **使用BigInt（如果适用）**

如果你处理的是非常大的整数，并且不希望有任何精度丢失，那么可以考虑使用`BigInt`。但请注意，`BigInt`不支持小数部分，仅用于大整数。

## JS的作用域

**作用域指一个变量的作用的范围** 

### 全局作用域

直接写在 script 标签中的 JavaScript 代码都是全局作用域。当页面打开运行时全局作用域就会自
动创建，而当页面关闭时就会销毁。在全局作用域中有一个全局的 window 对象可以使用，而所
有全局作用域对象都会作为 window 对象的属性来使用。

### 函数作用域

作用于函数内的代码环境，就是局部作用域。由于跟函数有关，所以也称为函数作用域。

局部作用域（函数作用域）是在调用函数时才会被创建，函数执行完毕后就自动销毁。同时，每调用一次函数就会创建一个新的函数作用域，它们之间是相互独立的。如果在函数中定义变量时没有指定 var 关键字，那么这个变量会自动提升为全局作用域的变量。

#### 块级作用域

**ES6 之前 JavaScript 没有块级作用域,只有全局作用域和函数作用域**。ES6 的到来，为我们提供了‘块级作用域’,可通过新增命令 let 和 const 来体现。声明变量不会提升到代码块顶部

一层一层向上寻找，直到找到全局作用域还是没找到，就宣布放弃。这种一层一层的关系，就是 作用域链 。

**执行上下文在运行时确定，随时可能改变；作用域在定义时就确定，并且不会改变**

### 改变作用域的三种方式

使用apply()方法  使用call()方法  使用new关键字 with语句用于临时拓展作用域链

## JS事件循环(Event Loop)

### 执行栈与任务队列

JS 在解析一段代码时，会将同步代码按顺序排在某个地方，即执行栈，然后依次执行里面的函数。当遇到异步任务时就交给其他线程处理，待当前执行栈所有同步代码执行完成后，会从一个队列中去取出已完成的异步任务的回调加入执行栈继续执行，遇到异步任务时又交给其他线程，…，如此循环往复。而其他异步任务完成后，将回调放入任务队列中待执行栈来取出执行。\

js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为事件队列。

JS 按顺序执行执行栈中的方法，每次执行一个方法时，会为这个方法生成独有的执行环境（上下文 context)，待这个方法执行完成后，销毁当前的执行环境，并从栈中弹出此方法（即消费完成），然后继续下一个方法。

可见，在事件驱动的模式下，至少包含了一个执行循环来检测任务队列是否有新的任务。通过不断循环去取出异步回调来执行，这个过程就是事件循环，而每一次循环就是一个事件周期或称为一次 tick。

下面我们看一下常见宏任务和常见微任务。

常见宏任务：

- setTimeout()
- setInterval()
- setImmediate()

常见微任务：

- promise.then()、promise.catch()
- new MutaionObserver()
- process.nextTick()

```javascript
console.log('同步代码1');
setTimeout(() => {
    console.log('setTimeout')
}, 0)
new Promise((resolve) => {
  console.log('同步代码2')
  resolve()
}).then(() => {
    console.log('promise.then')
})
console.log('同步代码3');
// 最终输出"同步代码1"、"同步代码2"、"同步代码3"、"promise.then"、"setTimeout"
//虽然 promise.then 写在后面，但是执行顺序却比 setTimeout 优先，因为它是微任务；
//new Promise 是同步执行的，promise.then 里面的回调才是异步的。
```

简单小结一下微任务和宏任务的本质区别。

宏任务特征：有明确的异步任务需要执行和回调；需要其他异步线程支持。Ajax请求 setTimeout
微任务特征：没有明确的异步任务需要执行，只有回调；不需要其他异步线程支持。

ES6引入Promise后，出现了微任务的概念。微任务是由JS引擎发起的诸如Promise、Promise.nextTick等异步任务，而由宿主（浏览器/node）发起的诸如Ajax请求、setTimeout等称之为宏任务。JS是单线程，一次只能执行一个任务。

总结下运行机制：

- 先将所有同步任务执行完毕；
- 一旦执行栈中的所有同步任务执行完毕（此时 JS 引擎空闲），系统就会读取任务队列；
- 首先读取微任务队列，若遇到微任务，就执行依次执行当前微任务队列中的所有微任务；
- 所有微任务执行完毕，开始检查渲染，然后GUI线程接管渲染；
- 渲染完毕后，JS线程继续接管，开始下一个宏任务（依次从宏任务队列中获取）；
- 执行完一个宏任务，需判断是否有新的微任务，若无，则浏览器渲染后继续执行下一个宏任务

**避免JS阻塞页面加载：**一种方法是将运算放在后端。如果必须在前端处理巨量运算，并且巨量计算还和 UI 有关系，可以使用 setTimeout 将任务分割，中间给出一点空闲时间让 JS 引擎去处理下 UI，不至于页面直接卡死

## 为什么宏任务、微任务

如果有一个高优先级的任务（例如DOM变化、UI更新等等），那就只能等待前面队列中的事件执行完毕，这时候执行的时间并不能被精确控制，可能受其他任务的影响，导致执行时间比预计的时间更长。对于比较要求实时的场景，这种时间间隔太长，用户很容易就感觉到卡顿或者延迟。

引入微任务之后，相对应的消息队列中的任务称为宏任务。每个宏任务中都会包含一个微任务队列。

执行宏任务的过程中，例如DOM产生变化，会将该事件添加到该宏任务的微任务队列中，不会影响当前宏任务的执行，这样就解决了执行效率的问题。

对于实时性，在当前宏任务完成之后，会执行该宏任务中的微任务队列的任务，等该微任务队列执行完成之后，才会继续执行下一个宏任务，这就解决了实时性的问题。

![image.png](https://p9-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/be117ea4e79c4d31bc7b7318a14ab783~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

**微任务**

在浏览器里，微任务产生的方式有两种：

- Promise中调用resolve() 和 reject() 会产生微任务，并将对应的任务按照顺序添加到当前宏任务的微任务队列上
- 使用 MutationObserver API 观察 DOM 变化时，其回调也会被添加到微任务队列中。

**区别**

宏任务和微任务本质上就是异步回调，但是各自执行时机不同。

- 宏任务：是添加到消息队列，当事件循环到这个任务的时候就会执行回调
- 微任务是添加到微任务队列，是在主函数执行结束之后，当前宏任务结束之前执行回调

作者：高楼随想
链接：https://juejin.cn/post/7261203102091034684
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 防抖和节流

防抖就是防止抖动，避免事件的重复触发

**总结**：等用户高频事件完了，再进行事件操作。**在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。**延时触发

**设计思路**：[事件触发](https://so.csdn.net/so/search?q=事件触发&spm=1001.2101.3001.7020)后开启一个定时器，如果事件在这个定时器限定的时间内再次触发，则清除定时器，在写一个定时器，定时时间到则触发。

1. search搜索联想，用户在不断输入值时，用防抖来节约请求资源
2. window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次

```javascript
function debounce(fun,delay){
    let timer
    return function(){
        clearTimeout(timer)
        let args=arguments
        timer=setTimeout(() => {
           fun.apply(this,args)
        }, delay);
    }

```

如果一直操作，会一直不触发。比如说是一个按钮，点击就发送请求，如果一直点，那么请求就会一直发布出去。这里正确的思路应该是第一次点击就发送，然后上一个请求回来后，才能再发。

节流就是减少流量，将频繁触发的事件减少，并每隔一段时间执行。即，控制事件触发的频率

#### 事件循环中的 setTimeout

JavaScript 的事件循环（Event Loop）负责协调任务执行，包括宏任务（macrotasks，如 setTimeout）和微任务（microtasks，如 Promise）。setTimeout 在防抖中的工作流程如下：

- **触发事件**：用户触发事件（如输入或点击），调用防抖函数。
- **创建定时器**：setTimeout 将回调函数推入宏任务队列，计划在 delay 毫秒后执行。
- **清除定时器**：如果事件再次触发，clearTimeout 移除之前的宏任务。
- **重新设置定时器**：新的 setTimeout 创建一个新的宏任务。
- **执行回调**：当没有新事件触发且 delay 时间到，事件循环从宏任务队列取出回调并执行。

考虑点：定时器管理开销、非精确计时实际执行时间可能略超 delay、setTimeout 不保证精确的 delay 时间、

 **规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。**

**总结：**某个操作希望上一次的完成后再进行下一次，或者希望隔一段时间触发一次。

1. 鼠标不断点击触发，mousedown(单位时间内只触发一次)
2. 监听滚动事件，比如是否滑到底部自动加载更多

```javascript
function throttle(fun,time){
    let start=0
    return function(){
        let end=new Date()
        let args=arguments
        if(end-start>time){
            fun.apply(this,args)
            start=end
        }
    }
}
```



## 闭包

闭包是函数和声明该函数的词法作用域的组合 **「函数」和「函数内部能访问到的变量」的总和，就是一个闭包。**从函数外部能访问函数内部的变量就是闭包。

闭包常常用来「间接访问一个变量」。换句话说，「隐藏一个变量」。

## 关于 ts 的了解

TypeScript 是一种由微软开发的自由和开源的编程语言。它是 JavaScript 的一个超集，而且本质上向这个语言添加了可选的静态类型和基于类的面向对象编程。

![img](https://p1-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/dea0cbad55b246a8a7e65aec57273ade~tplv-k3u1fbpfcp-zoom-in-crop-mark:3024:0:0:0.awebp)

Boolean 类型 Number 类型 String 类型 Symbol 类型  Array 类型 Enum 类型 Any 类型  Unknown 类型 Tuple 类型

Void 类型 Null 和 Undefined 类型  object, Object 和 {} 类型

## js原生的生命周期

JS引擎会以栈(遵循后进先出的数据存储方式)的方式来处理执行上下文，也就是我们通常所说的函数调用栈。栈底永远是全局上下文，栈顶则是当前正在执行的上下文. 处于栈顶的执行上下文执行完毕后，会自动出栈.

当一个函数调用时，一个新的执行上下文就会被创建，一个执行上下文的生命周期可分为两个阶段：

1. 创建阶段 --- 此阶段执行上下文会分别创建变量对象、确认作用域链、以及确定this指向.
2. 执行阶段 --- 执行代码，这个时候会完成变量赋值、函数引用、以及执行其他可执行代码等工作.

![img](https://pic2.zhimg.com/80/v2-6832e9a5fd77e37d47993da83e005a51_720w.webp)

## 同时发送三个请求

​         

## 哪些行为阻塞页面的渲染

哪些：html文件的加载自上而下的，加载加载link资源,css,javascript（阻止解析）

避免：defer和async  使用`defer`（延迟执行，等DOM解析完成再执行JS脚本）和`async`（异步执行，保证DOM树和JS脚本并行执行）

\- async 脚本下载和dom解析并行，脚本下完立即执行
\- defer 脚本下载和dom解析并行，脚本延迟dom解析完执行

## ES6里面的E和S分别指的是什么？

ES6是ECMAScript的第6个版本

## ECMAScript和JavaScript的区别是什么？

ECMA是一个组织，ECMAScript是标准化的脚本程序设计语言关于脚本语言的规范标准，JavaScript是他的实现

## 从JavaScript中把ECMAScript踢出去，剩下的是什么？

JavaScript由ECMAScript、DOM、BOM三部分组成

（1）ECMAScript：描述了该语言的语法和基本对象。

（2）DOM：文档对象模型（DOM），描述处理网页内容的方法和接口。

（3）BOM：浏览器对象模型（BOM），描述与浏览器进行交互的方法和接口。

## CommonJS和ES6

(https://www.cnblogs.com/TheoryDance/p/16188621.html)

### CommonJS

CommonJS就是为JS的表现来制定规范，因为js没有模块的功能所以CommonJS应运而生，它希望js可以在任何地方运行，不只是浏览器中。CommonJS是nodejs也就是服务器端广泛使用的模块化机制。该规范的主要内容是，模块必须通过module.exports 导出对外的变量或接口，通过 require() 来导入其他模块的输出到当前模块作用域中。根据这个规范，每个文件就是一个模块，有自己的作用域，文件中的变量、函数、类等都是对其他文件不可见的。

整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取 3 个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。因此commonjs属于再运行时才会加载模块的方式。

### ES6

使用export关键字将任意变量、函数或者类公开给其他模块。模块的默认值是使用 default 关键字所指定的单个变量、函数或类，而你在每个模块中只能设置一个默认导出。在模块中使用import关键字来导入其他模块。

从fs模块加载 3 个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高;

`1`: CommonJS 模块输出的是一个值的拷贝，ES6 模块输出的是值的引用 

`2`: CommonJS 模块是运行时加载，ES6 模块是编译时输出接口 

`3`: CommonJS 模块的require()是同步加载模块，ES6 模块的import命令是异步加载，有一个独立的模块依赖的解析阶段

回答要点：
`1`: 语法差异  

**CJS**：使用`require()`函数来导入模块，`module.exports`或`exports`对象来导出模块

**ESM**：使用`import`语句来导入模块，`export`语句来导出模块

`2`:加载方式

**CJS**：采用同步加载模块的方式，当`require()`被调用时，Node.js会暂停执行当前脚本，直到模块被加载并准备好执行。

**ESM**：采用异步加载模块的方式，即在模块加载过程中不会阻塞代码执行

`3`: 导出和导入的特性

**CJS**：只支持整个模块的导入和导出，即导入的是模块的`module.exports`属性的拷贝。

**ESM**：支持导入和导出命名的模块成员、默认导出和命名空间导入。

`4`: 静态编译与运行时加载

**ESM**：在静态阶段编译并分析模块的依赖关系，这使得编译器能够静态地确定模块之间的依赖关系

**CJS**：模块在运行时解析和执行，并且可以有条件地导入和导出模块。

`5`: 使用场景

**CJS**：主要用于服务器端，特别是Node.js环境

**ESM**：适用于现代浏览器和Node.js环境

## CJS和ESM能不能在浏览器直接使用

**CJS不能直接在浏览器中使用**。CJS是Node.js中的模块规范，通过`require`和`module.exports`进行导入和导出。由于浏览器原生不支持CJS的`require`语法，因此CJS模块无法直接在浏览器中运行。然而，通过构建工具如Webpack、Rollup等，可以将CJS模块转换为浏览器可以理解的格式（如ES5或ES6+的模块语法），从而实现在浏览器中使用CJS模块。

**ESM可以直接在浏览器中使用**，但需要注意浏览器的支持情况。ESM是ECMAScript 2015（ES6）中引入的模块系统，是现代JavaScript的标准模块规范。现代浏览器大多原生支持ESM，允许开发者通过`<script type="module">`标签在HTML文件中直接引入ESM模块。此外，浏览器还支持使用`import()`函数进行动态模块导入。

延伸：浏览器不支持ESM怎么办

### 使用构建工具转换模块

**主要工具**：Webpack、Rollup、Vite等。

- 这些工具可以将ESM模块转换为浏览器能够理解的格式，如CommonJS、AMD或立即执行函数表达式（IIFE）等。

###  使用Polyfill

SystemJS是一个通用的模块加载器，它可以作为ESM的polyfill，在不支持ESM的浏览器中模拟ESM的行为

作者：Story
链接：https://juejin.cn/post/7048139060983889950
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 手写promise

https://zhuanlan.zhihu.com/p/472989113

## 屏幕适配

css媒体查询代码量巨大,且变化过程不平滑, 响应式做法

vw适合定宽的不方便缩放的组件. 并不适合等比例缩放所有组件

rem布局 通过动态设置html根元素的fontsize，等比缩放元素大小来自适应移动设备。

## 对ES6的Proxy和Reflect是怎么理解的

**`Proxy`** 允许你拦截和修改对对象的操作，实现自定义的行为。

**`Reflect`** 提供了一些方法，允许你执行与 `Proxy` traps 对应的操作，简化代码并增强 `Proxy` 的功能。可以用于获取目标对象的行为，它与 Object 类似，但是更易读，为操作对象提供了一种更优雅的方式。

为什么要添加 Reflect 对象呢？它这样设计的目的是为了什么？

将 Object 对象的一些明显属于语言内部的方法(比如Object.defineProperty)放到 Reflect 对象上，那么以后我们就可以从 Reflect 对象上可以拿到语言内部的方法（当前某些方法会同时存在于 Object 和 Reflect 对象上，未来的新方法会只部署在 Reflect 对象上。)


push,pop,shift unshift,concat, join,reverse,sort,map,slice,splice,includes,indexOf,every,some,reduce

## 说一下map()的实现方式

### 思路分析

map是所有数组都可以用的方法，因此我们可以将方法挂在到Array.prototype上去
之后所有的数组都可以访问到这个方法
map函数，接收一个函数当作参数，并且这个函数有返回值，
之后对数组中每个元素都执行这个函数，最后将所有的执行结果返回

### 代码实现

```javascript
Array.prototype._map = function (fn) {
 // 传入的fn如果不是函数则直接返回
 if (typeof (fn) !== 'function') return
 // map方法会返回新数组
 const result = []
 // 给数组中的每一个方法都执行一次这个函数,并将返回值添加到result数组中
 // this指代的是当前调用的数组
 for (let i = 0; i < this.length; i++) {
   result.push(fn(this[i],i,this))
 }
 return result
}
let arr = [1, 2, 3, 4, 5, 6]
// 测试
console.log(arr._map(item => item + 'aaa'))
// 输出结果：[ '1aaa', '2aaa', '3aaa', '4aaa', '5aaa', '6aaa' ]
```



### forEach 的实现原理

`forEach`是JavaScript数组上的一个方法，它用于遍历数组并对每个元素执行一个回调函数。其典型实现大致如下：

```js
Array.prototype.forEach = function(callback, thisArg) {
  if (typeof callback !== 'function') {
    throw new TypeError(callback + ' is not a function');
  }
  for (let i = 0; i < this.length; i++) {
    if (i in this) {
      callback.call(thisArg, this[i], i, this);
    }
  }
};
```



## ES6中的弱引用的出现解决了什么样的问题？

`WeakMap` 可以用于 web 开发的两个领域：缓存和额外的数据存储。

WeakSet 应用场景，一个很典型的应用场景： **储存 DOM 节点，而不用担心这些节点从文档移除时，会引发内存泄漏**。

## 理解强引用

在讲弱引用之前，我们先来说下强引用。强引用就是将对象保留在内存中的引用。例如：

```js
let cat = { name: "Kitty" };
const pets = [cat];

cat = null;
console.log(pets); // [{ name: "Kitty" }]
```

通过将变量 `cat` 创建为对象，并把这个对象放入一个数组 `pets` 中，然后通过将它的值设置为 `null` 来删除其对原始对象的引用。

尽管我们再也无法访问 `cat` 变量，但由于在 `pets` 数组和这个对象之间存在**强引用**关系，因此这个对象其实仍保留在内存中，并且可以通过 `pets[0]` 访问到它。 换句话说，**强引用**可以防止垃圾回收从内存中删除对象。

## 理解弱引用

简单地说，**弱引用**是对对象的引用，如果它还是对内存中对象的唯一引用，就能顺利地进行垃圾回收。相反，一般强引用都会防止垃圾回收。可能还有些不太理解，让我们先来看个例子，我们将试着把刚才的代码中的强引用转换为弱引用。我们暂时先不展开讲 `WeakMap` ，这将在后面详细讨论，先就这个例子我们来观察下弱引用的行为。

```js
let pets = new WeakMap();
let cat = { name: "Kitty" };
pets.set(cat, "Kitty");
console.log(pets); // WeakMap {{…} => 'Kitty'}
cat = null;

// 等待垃圾回收后
console.log(pets); // WeakMap{}
```

通过利用 `WeakMap` 及其附带的弱引用，我们可以看到两种类型的引用之间的差异。虽然对原始 `cat` 对象的强引用仍然存在，但 `cat` 对象仍然存在于 `WeakMap` 中，我们可以毫无问题地访问它。

有内容的话：**解释为：因为浏览器的垃圾回收机制是不受我们控制的，我们无法知道垃圾回收机制什么时候执行，之所以打印能出现内容，其实是因为打印的时候垃圾回收机制没有启动。所以我们可以认为，上图二中的打印在垃圾回收启动之后，它就是空的**

但是，当我们通过将 `cat` 变量重新赋值 null 来覆盖对原始 `cat` 对象的引用时，由于内存中对原始对象的唯一引用是来自我们创建的 `WeakMap` 的弱引用，所以它不会阻止垃圾回收的发生。这意味着当 JavaScript 引擎再次运行垃圾回收过程时，`cat` 对象将从内存和我们分配给它的 `WeakMap` 中删除。

**因此这里的关键区就别在于**，强引用可以防止对象进行垃圾回收，而弱引用则不会。

**默认情况下**，JavaScript 对其所有引用使用**强引用**，使用弱引用的唯一方法是使用 **WeakMap** 或 **WeakSet**。

需要注意的事，因为WeakSet 和 WeakMap 随时都可能被垃圾回收掉，所以他们都不支持被遍历

## 全排列

![img](https://img2023.cnblogs.com/blog/2084543/202212/2084543-20221215105256966-1546432694.png)

```javascript
const permute = (nums) => {
  // 一次的数据　
  const path = []
  // 所有的结果
  const res = []
  // 该位置的数字之前是否访问过，默认为0表示未访问过
  let use = new Array(nums.length).fill(0)
  // 遍历的深度
  let depth = 0

  // dfs(nums, depth, use, path, res)
  const dfs = () => {
    // 递归退出条件，如果深度等于数组长度，则说明已经遍历到树的叶子节点
    if (depth === nums.length) {
      res.push([...path])
      return
    }
    // 遍历数组
    for (let i = 0; i < nums.length; i++) {
      // 判断当前元素是否使用过，如果用过则跳出
      if (use[i]) {
        continue
      }
      path.push(nums[i])
      depth++
      use[i] = 1
      dfs(nums, depth, use, path, res)
      use[i] = 0
      depth--
      path.pop()
    }
  }
  dfs()
  return res

}
console.log(permute([1, 2, 3, 4]))
```

## JS 判断是否为数组的几种方法

- **`Object.prototype.toString.call(val) === '[Object Array]' // true为数组`**

- ### `Array.isArray`推荐，ES5中提供的来判断是否为数组

- **`val instanceof Array; // true为数组`  注意instanceof可以用来判断数组而不可以判断对象，因为数组本身就是一个类似于列表的高阶对象**

- `val.constructor === Array; // true 为数组`

- `Object.getPrototypeOf(val) === Array.prototype; // true为数组`

- `Array.prototype.isPrototypeOf(val); // true为数组`

- 

## map和foreach的区别？

- `map()` 会分配内存空间存储新数组并返回，`forEach()` 不会返回数据。
- `forEach()` 允许 `callback` 更改原始数组的元素。`map()` 返回新的数组。
- 里面所执行的都是函数个体，return一个，其余的也会继续执行，不能终止循环

## 异步解决方案

- **回调函数** 简单理解就是一个函数被作为参数传递给另一个函数。回调是早期最常用的一种异步解决方案。
- **发布订阅模式** 定义了对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将会得到通知。
- ES2015(ES6)标准化和引入了 **`Promise` 对象**，它是异步编程的一种解决方案。简单来说就是用同步的方式写异步的代码，可用来解决回调地狱问题。
- **`Generator`** 其实是一个函数，只不过是一个特殊的函数。普通函数，你执行了这个函数，函数内部不会停，直到这个函数结`Generator` 这个函数特殊之处就是中间可以停。
- ES2017 标准引入了 `async` 函数，使得异步操作变得更加方便。

## 浏览器数据存储技术

- Cookie、小型文本文件、用于跟踪用户会话和存储少量数据，例如用户身份，登录状态等、最大容量为4KB、Http请求中自动携带、可自行设置过期时间-----document.cookie = 

> Value：如果用于保存用户登录态，应该将该值加密，不能使用明文。
>
> HttpOnly：打勾表示只能通过http请求访问，不能被js访问，减少XSS攻击。
>
> Secure：Cookie只能在协议为 HTTPS 的请求中携带。
>
> SameSite：相同站点，不能在跨域请求中携带Cookie，减少CSRF攻击。None表示不需要同源，可以在跨站点请求中发送。

- LocalStorage、HTML5提供的一种持久化的本地存储机制，用于在浏览器中存储键值对数据、容量通常在5MB到10MB之间、不会随着每次请求被发送到服务器、localStorage.getItem、是持久化的，数据会一直保存在客户端直到被主动清除
- SessionStorage是一种在浏览器中存储数据的机制、一个会话级别的解决方案、只在当前会话中有效，当会话结束时数据将被删除、在浏览器会话结束时会被清除

> 本身sessionStorage就是每打开一个新窗口，就有一个自己的sessionStorage对象，关闭窗口即 过期当前窗口的sessionStorage；
> 但是通过A页面打开的B页面( 如：window.open('同源网址') )，会进行源网页sessionStorage复制，并在窗口B中可以访问到；
> 修改窗口A的sessionStorage，不会对窗口B内部的sessionStorage影响。

- IndexedDB是一种在浏览器中存储大量结构化数据的机制、一个类似数据库的解决方案、允许你存储和检索对象，支持事务和索引大约为50MB到500MB

区别：这些存储方式都受限于同源策略

数据访问     Cookie由后端(服务器)操作存储，其他三种由前端操作存储。

数据容量

生命周期

## 浏览器垃圾回收

### 是什么

js中最常用的垃圾回收方式就是标记清除。当变量进入环境时，例如，在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。

### GC优化策略

**新生区**中使用**Scavenge算法**

1. 标记====2. 清除垃圾数据和整理碎片化内存===== 3. 角色翻转

**老生区**中使用**标记-清除算法**和**标记-整理算法**

整理：让所有存活的对象都向内存的一端移动

###  泄漏点

1. DOM/BOM 对象泄漏；
    **标签中绑定 DOM/BOM 事件**
   解决：如果组件中使用了 `setInterval`，需要在 `beforeDestroy` 中做对应销毁处理；
2. script 中存在对 DOM/BOM 对象的引用导致；
3. JS 对象泄漏；
4. 通常由闭包导致，比如事件处理回调，导致 DOM 对象和脚本中对象双向引用，这个是常见的泄漏原因；
   闭包所引用的变量在函数外部

## 浏览器安全：xss/csrf/跨域

### XSS

**是什么**：Cross-Site Scripting（跨站脚本攻击）简称 XSS，是一种`代码注入攻击`。XSS 的本质是：恶意代码未经过滤，与网站正常的代码混在一起；浏览器无法分辨哪些脚本是可信的，导致恶意脚本被执行。

**怎么做**：攻击者通过在`目标网站上注入恶意脚本`，使之在用户的浏览器上运行。利用这些恶意脚本，攻击者可获取用户的敏感信息如 Cookie、SessionID 等，进而危害数据安全。

### CSRF

CSRF（Cross-site request forgery）跨站请求伪造：攻击者诱导受害者进入`第三方网站`，在第三方网站中，向`被攻击网站发送跨站请求`。利用受害者在被攻击网站`已经获取的注册凭证`，`绕过`后台的`用户验证`，达到冒充用户对被攻击的网站执行某项操作的目的。

![img](https://pic4.zhimg.com/80/v2-f2b6e91c9b0bc48eaecf2ecb644ca09f_720w.webp)

常见防御 XSS 攻击措施：

- CSP
- HttpOnly 防止劫取 Cookie
- 用户的输入检查
- 服务端的输出检查

常见防御 CSRF 攻击措施：

- 同源检测
- Token验证
- 分布式校验
- 双重Cookie验证
- Samesite Cookie

https://zhuanlan.zhihu.com/p/604967514

## 什么是跨域？跨域解决方法

同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能

所谓同源（即指在同一个域）就是两个页面具有相同的协议（protocol），主机（host）和端口号（port。

##  jsonp跨域

jsonp跨域其实也是JavaScript设计模式中的一种代理模式。在html页面中通过相应的标签从不同域名下加载静态资源文件是被浏览器允许的，所以我们可以通过这个“犯罪漏洞”来进行跨域。一般，我们可以动态的创建script标签，再去请求一个带参网址来实现跨域通信

```js
//原生的实现方式
let script = document.createElement('script');

script.src = 'http://www.nealyang.cn/login?username=Nealyang&callback=callback';

document.body.appendChild(script);

function callback(res) {
  console.log(res);
}
```

## 跨域资源共享 CORS

CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。 它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。

浏览器直接发出CORS请求----------------------在头信息之中，增加一个Origin字段-----------------------Origin字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求----------------------------------如果Origin指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。 浏览器发现，这个回应的头信息没有包含Access-Control-Allow-Origin字段（详见下文），就知道出错了，从而抛出一个错误，被XMLHttpRequest的onerror回调函数捕获。

https://zhuanlan.zhihu.com/p/32165437

## `预检请求`（option）

非简单请求是那种对服务器有特殊要求的请求，比如请求方法是PUT或DELETE，或者Content-Type字段的类型是application/json。

非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。

浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的XMLHttpRequest请求，否则就报错。

在 CORS 中，可以使用 OPTIONS 方法发起一个预检请求(一般都是浏览检测到请求跨域时，会自动发起)，以检测实际请求是否可以被服务器所接受。

- 预检请求报文中的 Access-Control-Request-Method 首部字段告知服务器实际请求所使用的 HTTP 方法；
- Access-Control-Request-Headers 首部字段告知服务器实际请求所携带的自定义首部字段。
- 服务器基于从预检请求获得的信息来判断，是否接受接下来的实际请求。
- 服务器所返回的 Access-Control-Allow-Methods 首部字段将所有允许的请求方法告知客户端。该首部字段与 Allow 类似，但只能用于涉及到 CORS 的场景中。

跨域资源共享标准**新增了一组 HTTP 首部字段**，允许服务器声明哪些源站有权限访问哪些资源。另外，规范要求，对那些可能对服务器数据产生副作用的 HTTP 请求方法（特别是 GET 以外的 HTTP 请求，或者搭配某些 MIME 类型的 POST 请求），**浏览器必须首先使用 OPTIONS 方法发起一个预检请求**（preflight request：似曾相识有没有？诶，对，上面那个错误信息中，就有一个这样陌生的词汇），从而获知服务端是否允许该跨域请求。服务器确认允许之后，才发起实际的 HTTP 请求。

在预检请求的返回中，服务器端也可以通知客户端，是否需要携带身份凭证（包括 Cookies 和 HTTP 认证相关数据）。所以跨域请求分两种：`简单请求和预检请求`。

- 一次完整的请求不需要服务端预检，直接响应的，归为简单请求；
- 响应前需要预检的，称为预检请求，只有预检请求通过，才有接下来的简单请求。

对于那些是简单请求，那些会触发预检请求，文章做了详细的总结，这里列出触发预检请求的条件

> 使用了下面任一 HTTP 方法：
> PUT
> DELETE
> CONNECT
> OPTIONS
> TRACE
> PATCH
>
> 人为设置了对 CORS 安全的首部字段集合之外的其他首部字段。该集合为：
> Accept
> Accept-Language
> Content-Language
> Content-Type (but note the additional requirements below)
> DPR
> Downlink
> Save-Data
> Viewport-Width
> Width
>
> Content-Type 的值不属于下列之一:
> application/x-www-form-urlencoded
> multipart/form-data
> text/plain

## 什么是函数柯里化（curry）

函数柯里化（curry）是函数式编程里面的概念。curry的概念很简单：只传递给函数一部分参数来调用它，让它返回一个函数去处理剩下的参数。

简单点来说就是：每次调用函数时，它只接受一部分参数，并返回一个函数，直到传递所有参数为止。

```js
const curry = (fn, ...args) => 
    // 函数的参数个数可以直接通过函数数的.length属性来访问
    args.length >= fn.length // 这个判断很关键！！！
    // 传入的参数大于等于原始函数fn的参数个数，则直接执行该函数
    ? fn(...args)
    /**
     * 传入的参数小于原始函数fn的参数个数时
     * 则继续对当前函数进行柯里化，返回一个接受所有参数（当前参数和剩余参数） 的函数
    */
    : (..._args) => curry(fn, ...args, ..._args);

function add1(x, y, z) {
    return x + y + z;
}
const add = curry(add1);
console.log(add(1, 2, 3));
console.log(add(1)(2)(3));
console.log(add(1, 2)(3));
console.log(add(1)(2, 3));

```

作者：IOneStar
链接：https://juejin.cn/post/6844904093467541517
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 双问号

？？

空值合并操作符??是一个逻辑操作符，当左侧的操作数为 null 或者 undefined 时，返回其右侧操作数，否则返回左侧操作数。

```js
console.log(null ?? "xx")
输出 xx
console.log(1 ?? "xx")
输出 1

```

#### 问号点 ?. (可选链操作符)

## ETag也有缺点：

1. ETag 需要计算文件指纹，这样意味着服务端需要更多的计算开销。如果文件尺寸大，数据多。并且计算频繁，那么 ETag 的计算就会影响服务器的性能。显然，ETag 在这样的场景下就不是很适合。
2. ETag有强验证和弱验证，所谓强验证，ETag 生成的哈希码深入到每个字节。哪怕文件中只有一个字节变了，也会生成不同的哈希值，它可以保证文件内容绝对的不变，但是，强验证非常消耗计算量。ETag 还有一个弱验证，弱验证是提取文件的部分属性来生成哈希值。因为不必精确到每个字节，所以它的整体速度会比强验证快，但是准确率不高。会降低协商缓存的有效性。

————————————————
版权声明：本文为CSDN博主「ZHANG.......」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/zyf971020/article/details/127276291

## Js为什么是单线程

你打开一个浏览器(应用程序)，那浏览器就是一个进程。打开浏览器后要做很多事情(各种分工)：发送请求，接受请求，渲染页面，执行js等等这些就是一个个线程。

这个要回到Js历史了，布兰登·艾奇(Brendan Eich)老哥用10天创造js。当时js用来干嘛，简单的浏览器交互，验证，操作一下dom是吧。那把它设计成那么复杂干什么，而且如果多线程的话，操作dom会出现麻烦的事情，假设一个线程读取DOM节点数据的同时，另一个线程把那个DOM节点删了，呵呵。所以js一个线程就够了，也就是一步一步顺序运行下来。

作者：前端猿Ry
链接：https://juejin.cn/post/6844903561164242952
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## Worker 线程

使用限制

1.同源限制Worker  必须和主线程的文件同源

2.文件限制Worker 线程无法读取本地文件，文件需要通过主线程读取到文件之后再传输给 Worker。

3.DOM操作限制

实际上 Web Worker 没有 window 的概念（也没有 document 对象，所以无法操作 Dom），其运行上下文环境是 WorkerGlobalScope 对象的实例，通过 self 关键字暴露出来。





## ts的理解，type和interface区别，泛型怎么理解

### 用interface描述**数据结构**，

接口是命名数据结构（例如对象）的另一种方式；与`type` 不同，`interface`仅限于描述对象类型

#### 用type描述**类型关系**

类型别名用来给一个类型起个新名字，使用 `type` 创建类型别名，类型别名不仅可以用来表示基本类型，还可以用来表示对象类型、联合类型、元组和交集。

#### `type`可以定义**基本类型别名**, 但是`interface`无法定义

####  联合类型 `type Student = {stuNo: number} | {classId: number}` 和 交叉类型 是很常用的，所以避免不了大量使用 `type` 的场景

#### **总结**

- `interface` 更适用于**定义对象的结构、类和对象间的继承**，且支持声明合并。
- `type` 更适合来**定义更复杂的类型**，如联合、交叉类型、元组等，不支持声明合并。

使用**泛型**类型参数`<T>`来表示函数的参数类型和返回值类型。通过使用泛型，我们可以在函数调用时指定具体的类型，从而保持类型安全。

## TypeScript 常用的工具类型

TypeScript 提供了丰富的工具类型，帮助开发者更方便地对类型进行操作。常用的工具类型包括：

- `Required<T>`：将属性设为必填
- `Readonly<T>`：将属性设为只读
- `Partial<T>`：将属性设为可选
- `Pick<T, K>`：选择部分属性
- `Omit<T, K>`：去除某些属性
- `Record<K, T>`：创建一个属性键为 `K` 类型、属性值为 `T` 类型的对象
- `Exclude<T, U>`：从 `T` 中排除 `U`
- `Extract<T, U>`：从 `T` 中提取 `U`
- `NonNullable<T>`：排除 `null` 和 `undefined`
- `ReturnType<T>`：获取函数返回值类型
- `InstanceType<T>`：获取构造函数的实例类型 

## Symbol

Symbol是ES6中新增的一种**基本数据类型**，用于表示独一无二的值。Symbol值在语言层面上解决了属性名冲突的问题，可以作为对象的属性名使用，并且不会被意外覆盖。

1. Symbol值可以作为私有属性来使用，因为无法通过对象外部访问对象中的Symbol属性,**用于创建对象的唯一属性键，避免属性名冲突**
2. Symbol值可以用于定义迭代器

用法：

`Symbol` 属性不会出现在 `for...in` 循环或 `Object.keys()` 中，但可以通过 `Object.getOwnPropertySymbols()` 获取。

```
Symbol.for()
const symbol1 = Symbol.for("key"); // 创建或获取全局 Symbol
const symbol2 = Symbol.for("key");

console.log(symbol1 === symbol2); // true
```

Symbol.for()产生相同值，传入字符串，全局维护了一张注册表

对象toString()方法，防止属性冲突（私有属性）







## for...of

数组、伪数组、set、map

原理：可迭代接口======迭代器模式

Symbol(itrator)   有点像genrator

**`for...in` 在数组上使用的问题**：虽然可以用 `for...in` 遍历数组的索引，但由于 `for...in` 遍历的是对象的可枚举属性，且可能遍历继承的属性，并且遍历顺序不一定按照数组索引顺序，因此在数组上不推荐使用 `for...in`。

**`for...of` 无法用于普通对象**：`for...of` 只能用于可迭代对象，而普通对象不是可迭代对象，所以如果直接用 `for...of` 遍历对象会报错。

| 特性           | `for...in`                             | `for...of`                                      |
| -------------- | -------------------------------------- | ----------------------------------------------- |
| 迭代内容       | 对象的**键**（属性名）或数组的**索引** | 可迭代对象的**值**（元素）                      |
| 适用对象       | 主要用于对象，也可以用于数组（不推荐） | 主要用于数组、字符串、`Map`、`Set` 等可迭代对象 |
| 适合遍历什么   | 遍历对象的属性                         | 遍历可迭代对象的元素                            |
| 返回的内容     | 对象的键名（属性名）                   | 可迭代对象的元素                                |
| 是否适用于对象 | 是                                     | 否（对象不是可迭代对象）                        |
| 是否适用于数组 | 是（返回的是索引，不推荐使用）         | 是（返回的是数组元素，推荐使用）                |

## JS中的事件冒泡、事件捕获、事件委托

`DOM`事件流（`event flow` ）存在三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。

**addEventListener的第三个参数**
在我们平常用的`addEventListener`方法中，一般只会用到两个参数，一个是需要绑定的事件，另一个是触发事件后要执行的函数，然而`addEventListener`还可以传入第三个参数：

> 第三个参数默认值是`false`，表示在事件冒泡阶段调用事件处理函数;
>
> 如果参数为`true`，则表示在事件捕获阶段调用处理函数。如果不写第三个参数则默认在事件冒泡阶段调用事件处理函数。

`事件冒泡（dubbed bubbling）`：当一个元素接收到事件的时候，会把他接收到的事件传给自己的父级，一直到 `window` （注意这里传递的仅仅是事件，例如`click、focus`等等这些事件， 并不传递所绑定的事件函数。）

事件源 =>根节点（由内到外）进行事件传播。

`事件捕获（event capturing）`： 当鼠标点击或者触发`dom`事件时（被触发`dom`事件的这个元素被叫作事件源），浏览器会从根节点 =>事件源（由外到内）进行事件传播。

事件捕获与事件冒泡是比较类似的，最大的不同在于事件传播的方向。

`事件委托`也称为`事件代理`。就是利用`事件冒泡`，把子元素的事件都绑定到父元素上。如果子元素阻止了事件冒泡，那么委托就无法实现。

应用场景：`1000`个`button`需要注册点击事件

如果循环给每个按钮添加点击事件，那么会增加内存损耗，影响性能

此时可以给`button`的父元素添加点击事件

作者：前端掘金者H
链接：https://juejin.cn/post/7192584563799883832
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

https://juejin.cn/post/7192584563799883832?searchId=20230829153207FD7F36019AC9F6A5CCF9

## []==[]

前面说得很乱，根据我们得到的最终的图3，我们总结一下==运算的规则：

- **undefined == null**，结果是**true**。**且它俩与所有其他值比较的结果都是false**。
- **String == Boolean**，需要两个操作数同时转为Number。console.log(1 == '1'); 
- **String/Boolean == Number**，需要String/Boolean转为Number。console.log(0 == false);
- **Object == Primitive**，需要Object转为Primitive(具体通过**valueOf**和**toString**方法)。console.log([1] == 1);   // true, 数组 [1] 会被转换为字符串 '1'，再与 1 比较

### 终极记忆口诀

1. **`null` 和 `undefined`**：
   - 仅彼此宽松相等（`null == undefined`），其他情况一律不主动转换。
2. **对象类型**：
   - 先调 `valueOf()`，再调 `toString()`，最后按字符串/数字规则比较。
3. **布尔值**：
   - 遇到 `==` 必先转数字（`false→0`，`true→1`）。
4. **空数组 `[]`**：
   - `toString()` 返回 `""`，`""` 转数字为 `0`。

### Object.is()

`Object.is()` 方法是 ES6 引入的一个新的相等判断方法，类似于 `===`，但它有一些不同的比较规则。它 **不进行类型转换**，并且在某些特殊情况下（如 `NaN` 和 `-0`），表现得与 `===` 不同。

在处理 `NaN` 和 `-0` 时有所不同。

- `NaN` 与 `NaN` 比较时返回 `true`（`===` 中 `NaN` 与任何值（包括自己）比较时都是 `false`）。
- `+0` 和 `-0` 被认为是不相等的，而 `===` 中它们被认为是相等的。

## map

与 Object 只能使用数值、字符串或符号作为键不同，Map 可以使用**任何 JavaScript 数据类型作为 键**。

## 数组中存储对象 用filter 用find的区别

### 1. **`filter()` 方法**

`filter()` 方法用于创建一个新数组，包含所有通过测试（由提供的函数实现）的元素。

#### 特点：

- **返回值**：返回一个包含所有满足条件的元素的新数组。
- **多个匹配**：如果数组中有多个元素满足条件，`filter()` 会将它们全部返回。
- **不修改原数组**：`filter()` 不会改变原数组，而是返回一个新的数组。

### 2. **`find()` 方法**

`find()` 方法返回数组中第一个符合条件的元素。如果没有找到符合条件的元素，则返回 `undefined`。

#### 特点：

- **返回值**：返回数组中第一个符合条件的元素，或者返回 `undefined` 如果没有找到匹配的元素。
- **单个匹配**：`find()` 只会返回第一个符合条件的元素，之后会停止继续查找。
- **不修改原数组**：`find()` 不会改变原数组。

## undefined

undefined 一般都来自于某个表达式最原始的状态值，不是人为操作的结果。当然，你也可以手动给一个变量赋值 undefined，但这样做没有意义，因为一个变量不赋值就是 undefined 

场景：

##### **声明一个变量，但是没有赋值**

#### **访问对象上不存在的属性或者未定义的变量**

#### **函数定义了形参，但没有传递实参**

#### **使用void对表达式求值**

### null

空值 。这个值的语义是，希望表示一个对象被人为的重置为空对象，而非一个变量最原始的状态 。 **在内存里的表示就是，栈中的变量没有指向堆中的内存对象。**

当一个数据不再需要使用时，我们最好通过将其值设置为null来释放其引用，这个做法叫做解除引用。不过解除一个值的引用并不意味着自动回收改值所占用的内存。解除引用的真正作用是让值脱离执行环境，以便垃圾收集器在下次运行时将其回收。解除引用还有助于消除有可能出现的循环引用的情况。这一做法适用于大多数全局变量和全局对象的属性，局部变量会在它们离开执行环境时(函数执行完时)自动被解除引用。



作者：水木同学_
链接：https://juejin.cn/post/6844903777506426893
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



## 遍历

`Object.keys` 会返回对象自身可枚举属性组成的数组，**而不会遍历原型上的属性。**

`for in` 在进行对象遍历时，会遍历对象原型上的属性，而我们只希望得到其自身的属性，这时可以使用 `hasOwnProperty` 来实现

`Object.getOwnPropertyNames` 可以得到对象自身的所有属性名组成的数组(包括不可枚举属性)  不能获取 `Symbol` 值作为名称的属性

```js
Reflect.ownKeys` 方法返回一个由目标对象自身的属性组成的数组，它的返回值等同于 `Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target))
```

![image-20230926164947298](C:\Users\chuncaicai\AppData\Roaming\Typora\typora-user-images\image-20230926164947298.png)

## 在 forEach 中使用 return 能中断循环吗？

> 从上面看出 forEach 中使用 return 是不能跳出循环的。 **那么如何中断 forEach 的循环**、

- 可以使用 try catch
- 或使用其他循环来代替，比如 用 every 和some 替代 forEach，every 中内部返回 false是跳出，some 中内部是 true 时 跳出

**`for in` 的循环性能循环很差。性能差的原因是因为：`for in` 会迭代对象原型链上一切 `可以枚举`的属性**

(缺点) `for in` 循环主要遍历数字优先，由小到大遍历

(缺点) `for in` 无法遍历 `Symbol`属性（不可枚举）。

(缺点) `for in` 会将公有(prototype) 中可枚举的属性也遍历了。可以使用 `hasOwnProperty`来阻止遍历公有属性

> for of 循环的原理是`按照是否有迭代器规范来循环的`，所有带有 `Symbol.iterator` 的都是实现了迭代器规范，比如数组一部分类数组，`Set,Map...`，`对象没有实现 Symbol.iterator 规范`，所以不能使用`for of`循环。

- 使用 `for of` 循环，首先会先执行 `Symbol.iterator` 属性对应的函数且返回一个对象
- 对象内包含一个函数 `next()` 循环一次执行一次 `next()`，`next()` 中又返回一个对象
- 这个对象内包含两个值分别是 `done：代表循环是否结束，true 代表结束；value：代表每次返回的值`。

## **`arguments` 为什么不是数组？**

要点：是什么 2 length 索引 有哪些  2 dom列表 argument对象 怎么转换 2 arrayFrom [...]拓展运算符

相似问题：

**有没有了解过类数组或者伪数组, 即arraylike这个概念, 以及如何把他们转换成真正的数组**

**类数组（Array-like）** 或 **伪数组（Array-like object）** 是一个常见的 JavaScript 概念。它描述的是那些看起来像数组的对象，尽管它们并不是数组。简单来说，类数组是具有以下特征的对象：

1. **具有 `length` 属性**：类数组对象通常会有一个 `length` 属性来表示包含的元素个数。
2. **元素是按索引访问的**：类数组对象的元素可以通过整数索引访问，例如 `obj[0]`、`obj[1]` 等

- `arguments` 是类数组(其实是一个对象)属性从0开始排，依次为0，1，2... 最后还有 `callee和length` 属性，`arguments` 的 `__proto__` 直接指向基类的 `object`，不具备数组的方法。

**常见的类数组对象**：

- 函数的 `arguments` 对象：在函数内部，`arguments` 对象包含了函数的所有传入参数，且是类数组。
- DOM 方法返回的节点列表（如 `NodeList`）：例如 `document.querySelectorAll()` 返回的结果是一个类数组对象。

####  使用 ES6 的扩展运算符 `...`

```js
function example() {
  const args = [...arguments];
  console.log(args); // 将类数组 arguments 转换成真正的数组
}

example(1, 2, 3); // 输出: [1, 2, 3]

```



### Array.from()`Array.from()` 是 ES6 引入的一个方法，专门用来将类数组对象或可迭代对象转换成真正的数组。它更加简洁和现代。

作者：LinYIYI
链接：https://juejin.cn/post/6976419561067249672
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



## 关于构造函数中this和prototype定义的属性和方法的不同

### this定义的属性和方法，是生成的每个实例有属于自己的属性和方法;

### prototype定义的属性和方法，是每个实例共同拥有一份构造函的引用属性和方法;

### 1. **`this` 的绑定规则**

在 JavaScript 中，`this` 的值取决于函数的调用方式，而不是函数的定义位置。以下是 `this` 绑定的几种常见情况：

#### **作为对象方法调用：**`this` 指向该对象。

#### **作为普通函数调用：**`this` 指向全局对象（非严格模式）或 `undefined`（严格模式）。

```js
function foo() {
    console.log(this);
}
foo(); // 输出全局对象（浏览器中是 window，Node.js 中是 global）
```



####  **作为回调函数传递：**

```js
const obj = {
    name: 'obj',
    method() {
        console.log(this.name);
    }
};
setTimeout(obj.method, 1000); // 输出 undefined 或全局对象的 name
```

#### **`this` 绑定丢失的原因：**

- 在 JavaScript 中，方法的 `this` 绑定是动态的，只有在调用时才能确定。
- 当你将 `this.setName` 作为函数传递时，它只是一个函数引用，**没有携带 `this` 的上下文**。
- 因此，当 `exector` 调用 `fun('333')` 时，`this` 会指向全局对象（非严格模式）或 `undefined`（严格模式）。
- 

## Object.create()

- new Object() 通过构造函数来创建对象, 添加的属性是在自身实例下。
- Object.create()方法创建的对象时，属性是在原型下面的，也可以直接访问 b.rep // {rep: "apple"} ,
  此时这个值不是吧b自身的，是它通过原型链**proto**来访问到b的值

- `Object.create()`
  描述：该方法创建一个新对象，使用现有的对象来提供新创建的对象的`__proto__`；
  格式：Object.create(proto[, propertiesObject])
  用法：如果用传统的方法要给一个对象的原型上添加属性和方法，是通过 `__propt__` 实现的

## object.a = 4 ；a的值可以改变吗，如果不想让它改变需要加什么属性



```js
const object = {
  a: 1,
  b: 2
};

Object.freeze(object);

// 尝试修改属性将不会生效
object.a = 4; // 不会改变，object.a 仍然是 1
console.log(object.a); // 输出: 1
```

```js
const object = {
  a: 1,
  b: 2
};

Object.defineProperty(object, 'a', {
  writable: false
});

// 尝试修改属性将不会生效
object.a = 4; // 不会改变，object.a 仍然是 1
console.log(object.a); // 输出: 1
```



## 页面出现白屏如何排查



## requestAnimation和requestIdleCallback区别

| 特性                 | `requestAnimationFrame` (RAF)        | `requestIdleCallback` (RIC)             |
| :------------------- | :----------------------------------- | :-------------------------------------- |
| **执行时机**         | 在浏览器下一次重绘之前执行           | 在浏览器空闲时执行                      |
| **优先级**           | 高优先级（与渲染相关）               | 低优先级（不影响渲染和用户交互）        |
| **适用场景**         | 动画、DOM 更新等需要与渲染同步的任务 | 日志记录、数据预加载等低优先级任务      |
| **回调参数**         | 时间戳（回调被触发的时间）           | `IdleDeadline` 对象（包含剩余空闲时间） |
| **是否支持超时设置** | 不支持                               | 支持（通过 `{ timeout }` 参数）         |

- **`requestAnimationFrame`**：用于高优先级任务，与浏览器渲染同步，适合动画和 DOM 更新。进度条、回到顶部
- **`requestIdleCallback`**：用于低优先级任务，在浏览器空闲时执行，适合不影响用户体验的后台任务。

# 网易云音乐

## 首页  HomeView.vue

### 导航栏nav.vue



### 轮播图  banner.vue

- n-skeleton 骨架屏 可以闪的占位符
- n-carousel

实现自适应:

```js
window.addEventListener("resize", getBannerHeight)
```

监听window.innerWidth的变化，调整高度

object-fit 属性指定元素的内容应该如何去适应指定容器的高度与宽度。

object-fit 一般用于 img 和 video 标签，一般可以对这些元素进行保留原始比例的剪切、缩放或者直接进行拉伸等。

| cover | 保持原有尺寸比例。但部分内容可能被剪切。               |
| ----- | ------------------------------------------------------ |
| fill  | 默认，不保证保持原有的比例，内容拉伸填充整个内容容器。 |



### 推荐歌单 PaPlayLists.vue

#### n-h3

#### CoverLists.vue

##### 功能：当鼠标移动到图片时候，图片动画变大变暗，移除时候复原

实现：

1. 准备两张图片，cover（图层1），shadow(图层0，透明0)
2. 鼠标悬停时

> **filter：brightness（倍数）；**当倍数值大于1的时候元素会变亮，小于1的时候元素会变暗
> 该属性的作用为调整元素当前的亮度，一般来说可以适用于鼠标悬浮到某元素时的提醒作用
>
> **:deep()的使用场景：**
>
> 如果给当前组件的style 节点添加了[scoped](https://so.csdn.net/so/search?q=scoped&spm=1001.2101.3001.7020) 属性，则当前组件的样式对其子组件是不生效的。如果想让某些样式对子组件生效，则需要使用:deep()。

```less
.coverImg {
          filter: brightness(0.8);
          :deep(img) {
            transform: scale(1.1);
          }
        }
```

##### 自定义鼠标右键

1. 点击鼠标之后，获取点击事件e，
2. 阻止默认行为，也就是事件冒泡e.preventDefault();
3. 使用nextTick().then(）更新右键选项，然后展示下拉菜单

> Vue是异步执行dom更新的，一旦观察到数据变化，Vue就会开启一个队列，然后把在同一个事件循环 (event loop) 当中观察到数据变化的 watcher 推送进这个队列。如果这个watcher被触发多次，只会被推送到队列一次。这种缓冲行为可以有效的去掉重复数据造成的不必要的计算和DOm操作。而在下一个事件循环时，Vue会清空队列，并进行必要的DOM更新。
> 当你设置 改变了一个新数据data，DOM 并不会马上更新，而是在异步队列被清除，也就是下一个事件循环开始时执行更新时才会进行必要的DOM更新。如果此时你想要根据更新的 DOM 状态去做某些事情，就会出现问题。。为了在数据变化之后等待 Vue 完成更新 DOM ，可以在数据变化之后立即使用 vue.nextTick(callback) 。这样回调函数在 DOM 更新完成后就会调用。
> ————————————————
> 版权声明：本文为CSDN博主「司徒小北」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
> 原文链接：https://blog.csdn.net/weixin_42333548/article/details/102606546

## 歌单详情页 playlistview.vue

### 经典双栏布局

左侧固定宽度，右侧flex:1,方向为row

### 媒体查询

使用 @media 查询，你可以针对不同的媒体类型定义不同的样式。

@media 可以针对不同的屏幕尺寸设置不同的样式，特别是如果你需要设置设计响应式的页面，@media 是非常有用的。

当你重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。

### position: sticky;

头部导航栏开始时相对定位顶部，当页面元素发生滚动，当达到给定的位偏移时变为固定定位。

### 给图片加阴影

1. 准备两张图片，
2. 一张在底部，
3. 设置样式和偏移

```less
.shadow {
        position: absolute;
        top: 12px;
        height: 100%;
        width: 100%;
        filter: blur(16px) opacity(0.6);
        transform: scale(0.92, 0.96);
        z-index: 0;
        background-size: cover;
        aspect-ratio: 1/1;
      }
```

### 播放歌单功能设计

1. 获取所有歌曲的dom,使用的是querySelectorAll() 

   > querySelectorAll()方法返回文档中匹配指定 CSS 选择器的所有元素，返回 [NodeList](https://www.runoob.com/js/js-htmldom-nodelist.html) 对象。
   >
   > NodeList 对象表示节点的集合。可以通过索引访问，索引值从 0 开始。

2. 然后遍历一遍，通过class属性判断是否有子元素正在播放，如果有的话，直接播放，没有的话

3. 取得第一个元素，模拟双击 window.dispatchEvent(event); 方法触发自定义事件setplayState(1)

### 分页的实现

1. 引入Pagination组件
2. 绑定当前页数数据变化时候的事件，即改变路由的page参数大小
3. 监听路由的变化，获取新的page值后重新请求歌单数据（id,offset,limit）
4. 数据更新后及时的渲染到页面

### 每首歌的item实现 Datalist.vue

## 歌曲播放与上一首下一首歌曲切换的实现

### 技术选型

howler.js 是一个新的 JavaScript 库用于处理 Web 的音频，该库最初是为一个 HTML5 游戏引擎所开发，但也可用于其他的 Web 项目。 非常强大的一款声音引擎。 功能强大，性能不错。同时支持很多声音格式以兼容各种浏览器。MP3, MPEG, OPUS, OGG, OGA, WAV, AAC, CAF, M4A, MP4, WEBA, WEBM, DOLBY, FLAC.

**然后最重要的一点就是循环点处理，我们自己手动写的声音循环在循环一次和下一次的衔接往往有些延迟，造成不连贯，Howler.js对于循环点的处理性能不错，延迟比较小，非常适合多段音频连续播放的需求，同时控制多个声音播放非常方便，效果也不错。**

### 初始化播放器

初始化播放器后会有不同的事件监听节点，具体有以下几个事件

- load：从缓存取出上次播放到的时间节点，设置音频从该处播放
- play：开始播放，将当前歌曲添加到历史播放队列,设置一个定时器，不断将声音的播放进度同步至pinia-music
- pause：清除定时器
- end:切歌---》pinia

1. 双击一首歌后，设置当前歌单，以及该歌的索引，pinia将该歌曲设置为播放的歌，
2. 初始化一个播放器对象，player.value = createSound(url );
3. 将歌词存入pinia
4. 按下暂停后，对Pinia中的播放状态进行设置，并对这个状态进行监听，变化后调用player里的播放和暂停

### 播放模式







作者：胖子超人
链接：https://juejin.cn/post/6844904099054354446
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



PC端和移动端开发的区别

学习和做项目的过程中有哪些比较难或者有意思的部分

## 歌词的滚动是怎么实现的

调整滚动的距离，距离的计算为`var offset = liHeight * index + liHeight / 2 - containerHeight / 2*;*`



## 如何获得当前歌词播放的时间节点的

- 点击播放，设置定时器setInterval，并调用checkAudioTime，动态获得并改变当前歌曲的播放时长，当前已经播放时间（store中）

```javascript
 const currentTime = sound.seek();
 const duration = sound._duration;
```

- 改变后，调用setPlaySongTime，计算进度条需要移动的位置

```javascript
(value.currentTime / (value.duration / 100)).toFixed(2)  //平分100等分
```

- 计算当前歌词播放索引，根据播放的时间，在歌词中寻找索引

```javascript
lyrics?.findIndex((v) => v?.time >= value?.currentTime);
```

歌曲播放的时候，状态`currentTime`会不停地更新。但是即便如此`currentTime`也并不一定会和歌词数组里面的`time`字段相等，因为此处`currentTime`是一个6位小数的浮点数，事件`ontimeupdate`的触发也不是一定的，所以`currentTime`和歌词中的歌词时间不一定完全匹配。

所以在比较的时候，只需要比较到秒级，不需要精确到毫秒级。另外，`currentTime`和歌词时间的比较有2种情况：

1. `currentTime`和某句歌词时间相等，歌词的索引就是当前播放的歌词；
2. `currentTime`时间小于某句歌词时间，上一句歌词就是当前播放的歌词；

## 使用了什么组件获得，audio或者定时器

定时器

## 时间回调的单位是多少，多少毫秒

250ms

## 歌词滚动的动画是怎么实现的

1. 通过`document.querySelectorAll(".lyric-item")`获取所有歌词的元素，根据每个元素的`clientHeight`获取元素的高度；
2. 根据当前播放歌词的索引，获取当前歌词元素到顶部的距离，并设置滚动到顶部的距离；
3. 同时根据当前歌词的索引，就可以设置歌词的高亮样式；
4. 同时，根据元素的高度还可以设置当前歌词居中；
5. transition: transform 0.3s ease, opacity 0.3s ease, filter 0.3s ease;

## 自动往下滚动的效果怎么做，比如ppt播放这样



## 性能优化

### 图片

懒加载--lazy

[`HTMLImageElement`](https://developer.mozilla.org/zh-CN/docs/Web/API/HTMLImageElement) 的 **`loading`** 属性为一个字符串，它的值会提示 用户代理 告诉浏览器不在可视视口内的图片该如何加载。这样一来，通过推迟图片加载仅让其在需要的时候加载而非页面初始载入时立刻加载，优化了页面的载入。、

### 防抖节流

- 输入框搜索
- 表单提交按钮



# 项目

## 业界前端发布的成熟流程

### 开发阶段

版本管理

对于一般的前端项目，这里做两点区分，一个是纯静态项目，简而言之就是纯html+Css+js的项目；一个是Node项目，也就是除了纯静态文件，还有一层node层为我们做资源分发、接口转发等工作的项目

### 打包阶段

**webpack**

我们通过vue等前端框架开发的项目，比如在项目里看到的.vue文件等等，目前浏览器是无法识别的。要让我们的项目在浏览器中执行，必须要将项目打包成css+html+js的文件，也就是最原始的前端静态文件。vue这些前端框架只是为了方便我们的模块化开发及管理，最终运行是需要我们打包生成的产物。那么，如webpack这一类的打包工具，就是做这样的事情的。

在我们的开发阶段，其实也是通过打包工具，将我们的vue代码打包成了dist目录从而在浏览器中显示的，如果要部署到测试环境、线上环境，则就是将webpack打包后的项目部署到对应的环境中。


### 测试环境

jenkins是用于做持续集成的，公司基于jenkins有一个测试环境打包部署的平台，是为了简化打包部署流程所设，各项目可以进行一些配置，比如执行一些打包命令脚本，将我们的项目打包并部署在某某环境中。前面有提到打包阶段，jenkins上面的配置就可以让我们配置git分支，帮我们在指定的容器中将代码的git仓库拉下来，安装依赖，打包部署等，从而我们才能通过测试域名访问特定代码（域名映射通常是运维来做的。）

前端资源的加载速度是衡量用户体验的重要指标之一。而现实中，因为种种因素，用户在加载页面资源时，会受到很多限制。

用户来自不同地区，加入CDN可以使用户访问资源时，访问离自己比较近的CDN服务器，降低访问延迟；    

- ​        降低服务器带宽使用成本；    
- ​        支持视频、静态资源、大文件、小文件、直播等多种业务场景；    
- ​        消除跨运营商造成的网络速度较慢的问题；    
- ​        降低DDOS攻击造成的对网站的影响；



## 打包构建工具 webpack

- webpack可以帮助我们进行模块化，并且处理模块间的各种复杂关系后，打包的概念就很好理解了。
- 就是将webpack中的各种资源模块进行打包合并成一个多个包（Bundle）
- 并且在打包的过程中，还可对资源进行处理，比如压缩图片，将scss转成css，将ES6语法转成ES5语法，将TypeScript转成JavaScript等等操作。
- 打包工具还有grunt/gulp

### webpack 的核心概念

- entry: 入口
- output: 输出
- loader: 模块转换器，用于把模块原内容按照需求转换成新内容
- 插件(plugins): 扩展插件，在webpack构建流程中的特定时机注入扩展逻辑来改变构建结果或做你想要做的事情

### webpack 的构建流程是什么

- `初始化参数`：解析webpack配置参数，合并shell传入和webpack.config.js文件配置的参数,形成最后的配置结果；
- `开始编译`：上一步得到的参数初始化compiler对象，注册所有配置的插件，插件 监听webpack构建生命周期的事件节点，做出相应的反应，执行对象的run方法开始执行编译；
- `确定入口`：从配置的entry入口，开始解析文件构建AST语法树，找出依赖，递归下去；
- `编译模块`：递归中根据文件类型和loader配置，调用所有配置的loader对文件进行转换，再找出该模块依赖的模块，再递归本步骤直到所有入口依赖的文件都经过了本步骤的处理；
- `完成模块编译并输出`：递归完事后，得到每个文件结果，包含每个模块以及他们之间的依赖关系，根据entry或分包配置生成代码块chunk;
- `输出完成`：输出所有的chunk到文件系统；



性能优化



### loader 和 plugin 的区别、各自的作用、场景

`loader`是文件加载器，能够加载资源文件，并对这些文件进行一些处理，诸如编译、压缩等，最终一起打包到指定的文件中；`plugin`赋予了`webpack`各种灵活的功能，例如打包优化、资源管理、环境变量注入等，目的是解决 `loader`无法实现的其他事。

在运行时机上，`loader` 运行在打包文件之前；`plugin`则是在整个编译周期都起作用。

在配置上，`loader`在`module.rules`中配置，作为模块的解析规则，类型为数组。每一项都是一个 Object，内部包含了 `test(类型文件)`、`loader`、`options (参数)`等属性；`plugin`在 `plugins`中单独配置，类型为数组，每一项是一个 `plugin` 的实例，参数都通过构造函数传入。

## reuqire和import区别？

**CommonJS 模块化方案 require/exports 是为服务器端开发设计的**。服务器模块系统**同步读取模块文件内容**，编译执行后得到模块接口。（Node.js 是 CommonJS 规范的实现）。

## vite 本质上是 esbuild+rollup

> vite 本质上是 esbuild+rollup，你见过有多少业务项目用 rollup 打包的。本质上 rollup 跟 webpack 都能打包但是他们侧重点不一样。生产环境 vite 打包没webpack 快，开发环境下 vite 是 es module，但是生产还是要用Babel之类的转成非 es6 的外加压缩树摇之类的，webpack 在这些方面做了特定优化。我们之前也在生产用 vite 打包，最后发现构建速度比 webpack 慢太多了，就改成了开发环境 vite 生产环境 webpack

### 关键点总结：

#### 1. **Vite 的定位：**

- **开发环境**：Vite 利用浏览器原生支持的 ES Module 特性，实现了即时的模块热更新（HMR），依赖 `esbuild` 的超快速编译特性，让开发体验非常流畅。
- **生产环境**：使用 `rollup` 作为底层构建工具，专注于 Tree Shaking 和模块优化。虽然在功能上能完成生产构建，但在复杂场景下表现未必优于 Webpack。

#### 2. **Webpack 的优势：**

- **优化生态**：Webpack 的插件和 Loader 生态非常成熟，针对 Tree Shaking、压缩、跨浏览器兼容（Babel/Polyfill）等方面做了大量优化。
- **性能优化**：通过持久缓存（Persistent Caching）、分包（SplitChunksPlugin）等技术，Webpack 在复杂业务场景中更稳定高效。
- **大项目支持**：Webpack 针对大型业务场景有更多细粒度的调优手段，构建效率和资源优化上表现更强。

#### 3. **Vite 的瓶颈：**

- **生产构建**：Vite 使用 `rollup` 进行打包，但 `rollup` 的核心设计更多关注代码分块优化（Tree Shaking）和 Bundle 输出质量，而不是构建速度。
- **复杂业务场景**：面对多入口、多模块依赖的复杂场景，`rollup` 的构建速度可能会拖后腿。
- **兼容性需求**：Vite 默认是基于现代浏览器设计的（ES6+），如果项目需要兼容旧浏览器，生产环境往往需要额外工具（如 Babel）处理，增加构建时间。

#### 4. **实际场景：**

- **开发环境**：Vite 的极致快体验特别适合开发阶段，因为其基于 `esbuild` 的预编译能力，可以大幅提升模块解析和热更新速度。
- **生产环境**：如果业务场景复杂（比如多入口、多依赖、兼容旧浏览器），Webpack 的整体性能更好，且构建时间更短。

------

### 你的方案合理性

开发用 Vite，生产用 Webpack 的组合是一种很实际的解决方案。它兼顾了 Vite 的开发体验和 Webpack 的生产性能，充分利用了两者的强项。在这种模式下，可以实现以下优势：

1. **提升开发效率**：借助 Vite 快速热更新，让开发体验更加流畅。
2. **稳定生产构建**：利用 Webpack 在复杂场景下的优势，确保构建效率和最终产物的质量。

对于一些小型或中等复杂度的项目，Vite 可能足以承担全流程。但大型项目或对构建时间敏感的场景，Webpack 仍是更可靠的选择。

你们团队选择在生产环境中切换回 Webpack，说明这是一种经过实践验证的合理方案 👍



本质上 rollup 跟 webpack 都能打包但是他们侧重点不一样。生产环境 vite 打包没webpack 快，开发环境下 vite 是 es module，但是生产还是要用Babel之类的转成非 es6 的外加压缩树摇之类的，webpack 在这些方面做了特定优化。我们之前也在生产用 vite 打包，最后发现构建速度比 webpack 慢太多了，就改成了开发环境 vite 生产环境 webpack



### import属于 ES6 规范

**在浏览器端，因为其**异步加载脚本文件**的特性，CommonJS 规范无法正常加载。所以出现了 RequireJS、SeaJS 等（兼容 CommonJS ）为浏览器设计的模块化方案。直到 ES6 规范出现，浏览器才拥有了自己的模块化方案 import/export。**

在**编译过程中加载**,也就是说是在代码执行前执行,比如说,import后面的路径写错了,在运行代码前就会抛错,所以在编写代码时,必须放在模块顶部(import是静态执行的).

export default 为默认导出,**导出的是用{}包裹的一个对象**,以键值对的形式存在

### require 属于 CommonJS 规范

require是**运行时调用**,所以是动态执行的,所以require理论上可以运用在代码的任何地方，exports 是对 module.exports 的引用

1. require是赋值过程（require/exports 针对基础数据类型是值的拷贝，导出复杂数据类型时浅拷贝该对象）,import是解构过程（**JS 引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用。等到脚本真正执行时，再根据这个只读引用，到被加载的那个模块里面去取值。**）

2. 若文件引用的模块值改变，require 引入的模块值不会改变，而 import 引入的模块值会改变。

3. ### 用法不一致     import fs from 'fs'   const fs = require('fs')



## GIT

### 常用命令

- 初始化一个仓库：git init
- 查看分支：git branch
- 将已修改或未跟踪的文件添加到暂存区：git add [file] 或 git add .
- 提交至本地仓库：git commit -m "提及记录xxxx"
- 本地分支推送至远程分支：git push
- 查看当前工作目录和暂存区的状态: git status
- 查看提交的日志记录： git log
- 从远程分支拉取代码：git pull
- 合并某分支(xxx)到当前分支： git merge xxx
- 
- 切换到分支xxx：git checkout xxx
- 创建分支xxx并切换到该分支：git checkout -b xxx
- 删除分支xxx：git branch -d xxx
- 将当前分支到改动保存到堆栈中：git stash
- 恢复堆栈中缓存的改动内容：git stash pop



### 对GitFlow的理解？

GitFlow重点解决的是由于源代码在开发过程中的各种冲突导致开发活动混乱的问题。重点是对各个分支的理解。

- `master`：主分支。
- `develop`：主开发分支，平行于`master`分支。
- `feature`：功能分支，必须从`develop`分支建立，开发完成后合并到`develop`分支。
- `release`：发布分支，发布的时候用，一般测试时候发现的 bug 在该分支进行修复。从`develop`分支建立，完成后合并回`develop`与`master`分支。
- `hotfix`：紧急修复线上bug使用，必须从`master`分支建立，完成后合并回`develop`与`master`分支。



## 前端语义化，如何理解，为什么需要语义化

每个HTML元素都有具体的含义。

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/1/15/1684fa92ccb1bb5f~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.awebp)

### 为什么需要语义化？

1.为了搜索引擎优化（SEO）让搜索引擎更好理解网页，每隔一段时间，搜索引擎会从互联网抓取页面源代码，语义化做得越好，搜索引擎会更容易理解页面内容。

2.为了浏览器理解网页：阅读模式，语言模式，浏览器对网页的理解越深，这些模式就更方便。



## 什么样的代码是“好代码”，写代码的标准

**奇怪的命名方式**，**代码重复冗余**，**全局数据和可变数据**，**逻辑混乱**

那么什么好代码呢？

代码的好坏是根据代码质量进行评估的，最重要的衡量指标是：**可维护性、可阅读性和可扩展性**。要写出高质量代码，我们就需要掌握一些更加细化、更加能落地的编程方法论，这就包含面向对象设计思想、设计原则、设计模式、编码规范、重构技巧等。

## 代码重构？整个流程

**重构就是对既有代码进行有效的设计****结构调整**泛指的是对既有代码进行各种形式的重新组织或清理，而**重构**特指的是对特定类结构进行调整。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20200925191658331.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NjMxMzc5,size_16,color_FFFFFF,t_70#pic_center)

**封装成员变量**：变量重写成私有成员变量，并提供访问方法。这种重构方式可以将与外部调用者无关的变量隐藏起来，减少代码的耦合性，并减少意外出错的概率。

**提取方法**：将大段代码中的一部分提取后，构成一个新方法。这种重构可以使整段程序的结构变得更清晰，从而增加可读性。

**抽象出公用的基类**：将多个类/函数共用的类型抽象出可以公用的基类，然后利用多态性追加每个类/函数需要的特殊函数。这种重构可以让结构更加清晰，同时可以增加代码的可维护性。

应该从下至上，先理清晰要达到的目标，**先从底层逻辑开始重构，逐步到上层。比如在Android中对之前代码的重构，应该是先模块，后组件，然后逐渐到具体业务**，这样就可以保证整个过程中重构的一致性。

比如，某一次重构：

- 目标：完成所有业务模块的MVP重构
- 关键业务：打车、订单管理、地图
- 效果
  - 模块抽取（module1/moduel2...）
  - 基础组件
    - 推送/IM
    - 网络
    - 支付
    - ...
  - 规范
- 预估时间 30天/1人

## 如何观测重构后的效果？

我们不仅需要重构低效的代码，而且还可以通过修改低效代码增加价值。为了获得真正的价值，你需要进行测试，包括单元测试和功能测试。除此之外，还有一些其他方面的指标，比如发现的bug数减少，以及降低循环复杂性（重构的目标是降低复杂性）。

## JWT

###  JWT 原理，服务端随机生成一个字符串给到客户端行不行？

Header.Payload它默认这一部分数据为业务数据，是系统业务需要的数据，可有可无，可多可.Signature

- 因为 JWT 并不使用 Cookie 的，所以你可以使用任何域名提供你的 API 服务而不需要担心跨域资源共享问题（CORS）
- 因为用户的状态不再存储在服务端的内存中，所以这是一种无状态的认证机制

### JWT 怎么做验证的

将 Token 和 Payload 加密后存储于客户端，服务端只需要使用密钥解密进行校验（校验也是 JWT 自己实现的）即可，不需要查询或者减少查询数据库，因为 JWT 自包含了用户信息和加密的数据。

## **Token被窃取了怎么办？**

1. 存储上：客户端使用`HttpOnly`、`Secure`、`SameSite`的Cookie存储Token
2. 通过Refresh Token自动轮换Access Token
3. 多因素认证

## 浏览器存储

web storge



cookie



indexedDB

## 项目中存储在localStorage的数据如何防止溢出

```
localStorage`的存储上限通常为**5MB左右**（不同浏览器略有差异），超出会触发`QuotaExceededError
```

**数据精简**

使用`JSON.stringify`时添加空格参数（如`JSON.stringify(data, null, 0)`）减少体积，或采用二进制压缩（如`pako`库）。

**定期清理**

- **过期淘汰**：为每条数据添加时间戳，定期删除过期数据：

**分页存储**

- **拆分大对象**：将大型数据（如数组）拆分为多个键，按需加载。
- **LRU淘汰**：实现最近最少使用算法，优先保留高频访问数据。

## pinia 和 vuex 介绍与区别

![img](https://upload-images.jianshu.io/upload_images/5989807-b88e6ea16712532d.png?imageMogr2/auto-orient/strip|imageView2/2/w/640/format/webp)

- 🔨Pinia 与 Vuex 相比
  - 接口更简单，代码更简洁：
    - 舍弃了 mutation，减少了很多不必要的代码。
    - 可以直接对数据进行读写，直接调用 action 方法，不再需要 commit、dispatch。
  - 更好的 TypeScript 支持：
    - Vuex 中的很多属性缺少类型支持，需要开发者自行进行模块类型的声明。
    - Pinia 中的所有内容都是类型化的，尽可能地利用了 TS 的类型推断。

怎么解决全局变量太多的问题，怎么做模块化，模块化具体的操作与代码(这里问很细，就差让我一行一行写了);

在 Pinia 中，可以通过 `defineStore` 来创建多个 store，每个 store 就是一个模块。这样，避免了全局变量太多的问题，也能确保每个模块的独立性和易维护性。



pinia的原理简单介绍

#### **1. 响应式系统：Vue 3 的响应式系统（`reactive` 和 `ref`）**

Pinia 基于 Vue 3 的响应式系统来管理状态。它将每个 store 的 `state` 变成响应式对象，利用 Vue 3 的 `reactive` 和 `ref` 来自动追踪状态的变化。每当 `state` 更新时，相关的组件会被重新渲染。

##### **如何实现响应式：**

在 Pinia 中，`state` 被 `reactive` 包装成响应式对象。简单来说，Pinia 的 store 是通过 Vue 3 的响应式机制来管理的：

- **`reactive`**：用来创建响应式对象。当你定义 `state` 时，它会被 `reactive` 处理，使得 `state` 对象的所有属性都是响应式的。
- **`ref`**：用于创建简单类型（如字符串、数字、布尔值等）的响应式引用。

##### **工作原理：**

- 当访问某个 `state` 属性时，Pinia 会通过 Vue 的响应式系统（`Proxy`）来跟踪这个属性的依赖。
- 当 `state` 的某个属性被修改时，Vue 会通知依赖该属性的组件进行更新，达到自动更新 UI 的效果。

#### **2. Store 创建与状态管理：`defineStore` 和 `store` 实例**

在 Pinia 中，`defineStore` 用于定义一个 store，它返回的是一个 `store` 实例，而 `store` 实例包含了该 store 的 **state**、**getters** 和 **actions**。

##### **store 创建过程：**

1. **`defineStore`**：用于定义一个新的 store，`defineStore` 接收一个唯一的 store 名字和配置对象。
2. **store 实例**：`defineStore` 返回的 store 实例是响应式的，这意味着通过该 store 访问的状态和行为会自动更新组件。

##### **工作原理：**

- **state**：是一个响应式对象，存储组件的状态。
- **actions**：是一个方法集合，提供对 `state` 的修改（无论是同步还是异步）。
- **getters**：类似于计算属性，提供对 `state` 的衍生值。它们是响应式的，依赖于 `state` 的变化自动更新。

#### **3. 模块化管理：如何分割 Store**

Pinia 默认支持模块化，它通过多个独立的 store 实现应用的状态管理。每个 store 都是一个函数，并且完全独立，它们通过 `defineStore` 创建，因此你可以将应用中的不同状态划分为不同的模块。

##### **工作原理：**

- **Store 独立性**：每个 store 是独立的 JavaScript 对象，它们是通过 `defineStore` 来实例化的。这使得你可以在不同的地方使用不同的 store，避免了状态之间的混乱。
- **模块化实例**：每个 store 的实例都是响应式的，因此它们之间互不干扰，且可以被独立管理。

源码解读

### **1.createPinia**

```js
    _p, // 插件列表
    // it's actually undefined here
    // @ts-expect-error
    _a: null,// vue3 app应用实例
    _e: scope, // effectScope
    _s: new Map<string, StoreGeneric>(),// 一个map结构，存储storeId,与store实例的映射关系 存储我们在项目中定义的store实例
    state, // 所有的state的集合：每个store初始化时，都会将处理后state数据挂载到Pinia.state.value[$id]下面
    
    
    // app.provide()提供一个值，可以在应用中的所有后代组件中注入使用【重点】
    app.provide(piniaSymbol, pinia)

    pinia =
      // in test mode, ignore the argument provided as we can always retrieve a
      // pinia instance with getActivePinia()
      (__TEST__ && activePinia && activePinia._testing ? null : pinia) ||
      (hasContext ? inject(piniaSymbol, null) : null)


```

通过 provide 注入一个应用范围内**所有组件都可以使用的值**  应用范围内任意组件要使用provide提供的的值时，都可以**通过 inject 进行接收**



### **2.defineStore**

**defineStore**  `defineStore`方法的内容就很简洁明了了，首先处理传入的参数，然后定义了一个`useStore`方法并且返回，这里的重点是定义的`useStore`方法

**useStore**  进来调用了`inject()`来获取当前的pinia实例，这里拿到pinia实例是为了把即将创建的Store实例注册到`Pinia._s`属性中，以及将`state`中的数据都挂载到`Pinia.state.value[$id]`下面。

`useStore`方法主要作用就是**返回Store实例**供我们使用【无则创建，有则直接返回，避免重复创建】 这里根据`storeId`来查询`Pinia._s`属性值是否存在对应的store实例：

- 存在：则取出并直接返回store实例。
- 不存在：则根据之前`isSetupStore`变量的值来决定创建store实例的逻辑。

```js
// 重点，转换成ref数据
    const localState =
      __DEV__ && hot
        ? // use ref() to unwrap refs inside state TODO: check if this is still necessary
          toRefs(ref(state ? state() : {}).value)
        : toRefs(pinia.state.value[id])
    
    // 1，OptionsStore模式
export const useCounterStore = defineStore('counter', {
  state: () => {
    return { count: 0 }
  },
  actions: {
    increment() {
      this.count++
    },
  },
})
// 2，SetupStore模式
export const useCounterStore = defineStore('counter', () => {
  const count = ref(0)
  function increment() {
    count.value++
  }
  return { count, increment }
})



https://juejin.cn/post/7252683094204416060

```

**createOptionsStore**  它是具体的创建函数 从options选项对象中取出所需要的数据，然后定义了一个setup函数来处理相关的数据【初始化Store的方法】, 在setup函数中会将store设置到`pinia.state.value[id]`中，最后调用了`createSetupStore`这个方法来创建了一个Store实例，并且返回这个实例。



**createSetupStore**  **Pinia中创建Store的真正核心**  

#### a.挂载初始state数据对象  **在`pinia.state.value`属性下挂载一个空的state数据对象**，key为传入的StoreID。

#### b.$reset方法在option模式下重置state对象  

#### c.存储已经创建的store实例：

```js
// 定义了一个基础store：并且在它的实例上挂载了一些方法, 这里的所有函数都是用于plugins中使用
    const partialStore = {
      _p: pinia,
      // _s: scope,
      $id,
      $onAction: addSubscription.bind(null, actionSubscriptions),
      $patch, // 修改state
      $reset, // 重置state
      $subscribe() {}, // 监听
      $dispose,
    } as _StoreWithState<Id, S, G, A>
    ...
    // 使用partialStore为原对象: 创建一个响应式的Store实例
    const store = reactive(partialStore)
    
    // 将store添加到pinia._s的map结构中【重点】
    pinia._s.set($id, store)
    

作者：山间之明月
链接：https://juejin.cn/post/7252683094204416060
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
```

#### d.对`setupStore`对象的处理：

【将state中的内容全部转换为ref数据】和getters，最后使用对象的`Object.assign()`方法将state、actions、getters处理后的内容合并到一个新对象中，并且返回。

- 最后挂载到store实例上：











# 计算机网络

## https与http

### 改进

http的内容是明文传输的，明文数据会经过中间代理服务器、路由器、wifi热点、通信服务运营商等多个物理节点，如果信息在传输过程中被劫持，传输的内容就完全暴露了。劫持者还可以篡改传输的信息且不被双方察觉，这就是`中间人攻击`。所以我们才需要对信息进行加密。最容易理解的就是`对称加密`

### 加密过程

#### **非对称加密**

简单说就是有两把密钥，通常一把叫做公钥、一把叫私钥，用公钥加密的内容必须用私钥才能解开，同样，私钥加密的内容只有公钥能解开。

![img](https://pic1.zhimg.com/80/v2-1589bbfab027eb9f52da03c02a837fd4_720w.webp)

#### **改良的非对称加密方案**

1. 某网站服务器拥有公钥A与对应的私钥A’；浏览器拥有公钥B与对应的私钥B’。
2. 浏览器把公钥B明文传输给服务器。
3. 服务器把公钥A明文给传输浏览器。
4. 之后浏览器向服务器传输的内容都用公钥A加密，服务器收到后用私钥A’解密。由于只有服务器拥有私钥A’，所以能保证这条数据的安全。
5. 同理，服务器向浏览器传输的内容都用公钥B加密，浏览器收到后用私钥B’解密。同上也可以保证这条数据的安全。

都把自己的公钥给对方，然后对方用此加密发消息：非对称加密算法非常耗时--俩钥匙，仍有漏洞（两头骗）

#### **非对称加密+对称加密**

1. 某网站拥有用于非对称加密的公钥A、私钥A’。
2. 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
3. 浏览器随机生成一个用于对称加密的密钥X，用公钥A加密后传给服务器。
4. 服务器拿到后用私钥A’解密得到密钥X。
5. 这样双方就都拥有密钥X了，且别人无法知道它。之后双方所有数据都通过密钥X加密解密即可。

**服务器公钥给对方，对方用它加密自己密钥（对称）再返回来，这样双方都有同一把钥匙**

#### **中间人攻击**

1. 某网站有用于非对称加密的公钥A、私钥A’。
2. 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
3. **中间人劫持到公钥A，保存下来，把数据包中的公钥A替换成自己伪造的公钥B（它当然也拥有公钥B对应的私钥B’）**。
4. 浏览器生成一个用于对称加密的密钥X，用**公钥B**（浏览器无法得知公钥被替换了）加密后传给服务器。
5. **中间人劫持后用私钥B’解密得到密钥X，再用公钥A加密后传给服务器**。
6. 服务器拿到后用私钥A’解密得到密钥X。

**劫持了A，从而获得了共同的钥匙**

**如何证明浏览器收到的公钥一定是该网站的公钥**

数字证书里含有证书持有者信息、加密后服务器的公钥等。服务器把证书传输给浏览器，浏览器从证书里获取公钥就行了

浏览器验证过程：

1. 拿到证书，得到明文T，签名S。
2. 用CA机构的公钥对S解密（由于是浏览器信任的机构，所以浏览器保有它的公钥。详情见下文），得到S’。
3. 用证书里指明的hash算法对明文T进行hash得到T’。
4. 显然通过以上步骤，T’应当等于S‘，除非明文或签名被篡改。所以此时比较S’是否等于T’，等于则表明证书可信。

**能篡改吗？**

数字签名S私钥加密，中间人只能解密，改了不能再加密，那原文跟S就对不上了，那更换成另一个密钥呢，而浏览器只保存CA机构的公钥，因此无法解密伪造证书的数字签名因此无法验证。

它造假了证书原文后无法生成签名，如果它用自己的私钥生成签名，那么客户端用CA公钥肯定无法解开，或者解开得到错误的散列值，因此中间人不可能篡改证书

其实这并不会发生，因为证书里包含了网站A的信息，包括域名，浏览器把证书里的域名与自己请求的域名比对一下就知道有没有被掉包了

**因此中间人最多就只有查看的可能，而查看是没有用的，因为ca证书，数字签名，以及公钥都是明文，而非数据不怕被偷窥**

有用吗？中间人确实可以生成一个对称秘钥B并用服务器的公钥加密再发给服务器，随后使用秘钥B和服务器进行通信。但因为没有服务器的私钥，就没法获取到浏览器的秘钥A，也就没法和浏览器通信，等于说只劫持一半是没用的，影响不了安全，中间人：我成浏览器了![[笑哭]](https://pic4.zhimg.com/v2-ca0015e8ed8462cfce839fba518df585.png)

浏览器接收到另一个经过 CA 机构密钥加密的数据报，通过浏览器可以解密得到，明文T和签名S，第一步会先用签名 S 进行 Hash 判断明文 T 有没有被修改过，第二步，明文就包含了CA 机构分发给网站的证书以及，网站使用的非对称密钥。
证书不等于签名，签名的作用是保证证书等数据的正确性不被修改

**每次进行HTTPS请求时都必须在SSL/TLS层进行握手传输密钥吗？**

服务器会为每个浏览器（或客户端软件）维护一个session ID，在TLS握手阶段传给浏览器，浏览器生成好密钥传给服务器后，服务器会把该密钥存到相应的session ID下，之后浏览器每次请求都会携带session ID，服务器会根据session ID找到相应的密钥并进行解密加密操作，这样就不必要每次重新制作、传输密钥了！



### https还会有什么安全问题

1. HTTPS协议的加密范围也比较有限，在黑客攻击、拒绝服务攻击、服务器劫持等方面几乎起不到什么作用

> 拒绝服务 （DoS） 攻击
>
> 攻击者向目标服务器发送多个请求，使其流量过载。这些服务请求是非法的，并且具有伪造的返回地址，这会在服务器尝试对请求者进行身份验证时误导它。由于垃圾请求不断被处理，服务器不堪重负，会导致对合法请求者的 DoS 条件
>
> 服务器劫持：由于恶意攻击者控制了你的网关，当你发送了一个查找`freebuf.com`的IP的请求的时候，中间人拦截住，并返回给你一个恶意网址的IP,你的浏览器就会把这个IP当做你想要访问的域名的IP!!这个IP是攻击者搭建的一个模仿了目标网站前端界面的界面，当你在该界面输入用户名密码或者付款操作的时候，就会中招。

1. SSL证书的信用链体系并不安全，特别是在某些国家可以控制CA根证书的情况下，中间人攻击一样可行



## 路由器的作用



## Ipv4、IPv6 地址



## webSocket是怎么建立连接的（三次握手），websocket是处于七层模型的哪一层



## HTTP 缓存机制

**1.强缓存：**不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的Network选项中可以看到该请求返回200的状态码，并且size显示from disk cache或from memory cache两种（灰色表示缓存）。

- **Expires ：**response header里的过期时间，浏览器再次加载资源时，如果在这个过期时间内，则命中强缓存。
- **Cache-Control:**当值设为max-age=300时，则代表在这个请求正确返回时间（浏览器也会记录下来）的5分钟内再次加载资源，就会命中强缓存。

> 区别：Expires 是http1.0的产物，Cache-Control是http1.1的产物
> 两者同时存在的话，Cache-Control优先级高于Expires
> Expires其实是过时的产物，现阶段它的存在只是一种兼容性的写法

**2.协商缓存：**向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；

- **ETag和If-None-Match:**

Etag是上一次加载资源时，服务器返回的**response header**，是对该资源的一种**唯一标识**

只要资源有变化，Etag就会重新生成

浏览器在下一次加载资源向服务器发送请求时，会将上一次返回的Etag值放到**request header**里的**If-None-Match**里

服务器接受到If-None-Match的值后，会拿来跟该资源文件的Etag值**做比较**，如果相同，则表示资源文件没有发生改变，命中协商缓存。

- **Last-Modified和If-Modified-Since**

Last-Modified是该资源文件**最后一次更改时间**,服务器会在**response header**里返回

同时浏览器会将这个值保存起来，下一次发送请求时，放到**request headr**里的**If-Modified-Since**里

服务器在接收到后也会**做对比**，如果相同则命中协商缓存

> 在精确度上，Etag要优于Last-Modified，Last-Modified的时间单位是秒，如果某个文件在1秒内改变了多次，那么他们的Last-Modified其实并没有体现出来修改，但是Etag每次都会改变确保了精度
> 在性能上，Etag要逊于Last-Modified，毕竟Last-Modified只需要记录时间，而Etag需要服务器通过算法来计算出一个hash值。
> **在优先级上，服务器校验优先考虑Etag。**
> 所以，两者互补

**强缓存 VS 协商缓存：**最好是配合在一起用，争取最大化的减少请求，利用缓存，节约流量。

### **浏览器缓存过程：**

1. 浏览器**第一次**加载资源，服务器返回200，浏览器将资源文件从服务器上请求下载下来，并把**response header**及该请求的**返回时间**(要与Cache-Control和Expires对比)一并缓存；
2. 下一次加载资源时，先比较当前时间和上一次返回200时的**时间差**，如果没有超过Cache-Control设置的max-age，则没有过期，命中强缓存，不发请求直接从本地缓存读取该文件（如果浏览器不支持HTTP1.1，则用Expires判断是否过期）；
3. **如果时间过期**，服务器则查看header里的**If-None-Match**和**If-Modified-Since** ；
4. 服务器**优先根据Etag**的值判断被请求的文件有没有做修改，Etag值一致则没有修改，命中协商缓存，返回304；如果不一致则有改动，直接返回新的资源文件带上新的Etag值并返回 200；
5. 如果服务器收到的请求没有Etag值，则将**If-Modified-Since**和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回304；不一致则返回新的**last-modified和文件**并返回 200；

使用协商缓存主要是为了进一步降低数据传输量，如果数据没有变，就不必要再传一遍

### **用户行为对浏览器缓存的控制：**

**地址栏访问**：按照正常流程

**F5刷新：**跳过强缓存判断，会进行协商缓存判断

**ctrl+F5强制刷新：**跳过强缓存和协商缓存，直接从服务器拉取资源。

### **如何不缓存**

```http
Cache-Control: no-cache, no-store, must-revalidate
```

**Expires：设为当前时间之前**

在引用js、css文件的url后边加上 ?+Math.random()

![image.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/c57afe218c664ef9b92ede954c646e5d~tplv-k3u1fbpfcp-zoom-in-crop-mark:1512:0:0:0.awebp?)

参考文献：

https://zhuanlan.zhihu.com/p/58685072

## Cache-Control在请求头和在响应头的区别

在 HTTP 协议中，`Cache-Control` 头部用于指定缓存策略，控制客户端和服务器如何缓存资源。根据其在请求头或响应头中的位置，`Cache-Control` 的作用有所不同。

**请求头中的 `Cache-Control`：**

当客户端发送请求时，可以在请求头中包含 `Cache-Control`，以指示服务器如何处理缓存。常用指令包括：

- `no-cache`：强制向服务器验证资源的有效性，即使本地有未过期的缓存。
- `no-store`：不使用缓存，每次请求都从服务器获取资源。
- `max-age=<seconds>`：指示客户端希望接收不超过指定时间的资源。

例如，`Cache-Control: no-cache` 表示客户端要求服务器验证资源的最新性，即使本地缓存未过期。 `max-age=0`指示客户端希望获取最新内容，因此不使用缓存。

**响应头中的 `Cache-Control`：**

服务器在响应头中使用 `Cache-Control`，以指示客户端和中间缓存如何处理资源的缓存。常用指令包括：

- `public`：资源可以被任何缓存存储，包括共享缓存（如 CDN）。
- `private`：资源仅能被单个用户的缓存存储，不能在共享缓存中存储。
- `no-cache`：客户端在使用缓存前必须向服务器验证资源的有效性。
- `no-store`：资源不应被缓存，每次请求都应从服务器获取。
- `max-age=<seconds>`：指定资源在缓存中可存储的最大时间（以秒为单位）。

例如，`Cache-Control: max-age=3600, public` 表示资源可以被缓存，且缓存时间为 3600 秒。

**总结：**

- **请求头中的 `Cache-Control`**：由客户端设置，指示服务器如何处理缓存。
- **响应头中的 `Cache-Control`**：由服务器设置，指示客户端和中间缓存如何存储和使用资源。

通过在请求头和响应头中合理使用 `Cache-Control`，客户端和服务器可以有效地管理缓存策略，提升资源加载效率。

## 哪些资源强缓存，哪些资源协商缓存，为什么



| **因素**         | **强缓存**                 | **协商缓存**                  |
| ---------------- | -------------------------- | ----------------------------- |
| **资源更新频率** | 低频（如静态资源）         | 高频（如动态内容）            |
| **版本控制**     | 通过文件名/URL参数强制更新 | 依赖服务器验证（ETag/时间戳） |
| **网络请求开销** | 零请求（最优性能）         | 至少一次请求（验证或下载）    |
| **典型场景**     | 图片、CSS/JS、字体         | HTML、API数据、用户个性化内容 |



## http知道哪些？（我说了几个状态码）



## http有好几个版本，有哪些区别？

**HTTP/2是基于二进制“帧”的协议** HTTP 2.0成功解决了HTTP 1.x的队首阻塞问题（TCP层的阻塞仍无法解决），同时，也不需要通过pipeline机制多条TCP连接来实现并行请求与响应。减少了TCP连接数对服务器性能也有很大的提升。



## http用过哪些请求头？



## 二进制分帧层

### 一、定义与作用

二进制分帧层是HTTP/2协议在应用层（HTTP/2.0）和传输层（TCP或UDP）之间引入的一个新层。这一层的引入使得HTTP/2能够将所有传输的信息分割为更小的消息和帧，并采用二进制格式进行编码。这种设计方式使得HTTP/2能够在单个TCP连接上并行处理多个请求和响应，从而显著提高了传输效率和资源利用率。

### 二、主要组成部分

#### 1. 帧（Frame）

- **定义**：帧是HTTP/2协议中的最小单位，所有的HTTP/2通信都通过帧进行。
- **结构**：每个帧都包含一个固定长度的头部（通常为9字节）和一个可变长度的负载。头部包含长度、类型、标志和流标识符等信息，而负载则根据帧的类型不同而有所变化。
- **类型**：HTTP/2定义了多种帧类型，如DATA帧（用于传输消息体）、HEADERS帧（用于传输头部信息）、PRIORITY帧（用于设置流的优先级）、RST_STREAM帧（用于重置流）、SETTINGS帧（用于协商连接参数）等。

#### 2. 消息（Message）

- **定义**：消息是由一组帧组成的完整的逻辑请求或响应。在HTTP/2中，消息通常包含一个HEADERS帧后跟一个或多个DATA帧。
- **作用**：消息是HTTP协议的基本单元，用于传递客户端和服务器之间的请求和响应。通过将消息分割成多个帧，HTTP/2能够更有效地传输和管理数据。

#### 3. 流（Stream）

- **定义**：流是连接中的一个虚拟信道,流是HTTP/2中的一个独立的、双向的字节流，包含多个帧。每个流都有一个唯一的标识符，用于区分同一连接上的不同流。
- **作用**：流是HTTP/2实现多路复用的关键。通过在一个连接上同时存在多个流，HTTP/2可以并行处理多个请求和响应，从而避免了HTTP/1.1中的队头阻塞问题。

### 三、工作原理

在HTTP/2中，所有的通信都在一个TCP连接上进行。该连接可以承载任意数量的双向流（stream），每个流都有一个唯一的标识符和可选的优先级信息。每条消息（如请求或响应）是一个逻辑上的HTTP消息，由一个或多个帧组成。这些帧可以乱序发送，但在接收端会根据每个帧头部中的流标识符重新组装成完整的消息。

### 四、性能优势

- **多路复用**：通过在同一连接上并行处理多个请求和响应，HTTP/2显著提高了传输效率。
- **头部压缩**：HTTP/2使用HPACK算法对头部进行压缩，减少了传输的数据量。
- **服务器推送**：允许服务器主动向客户端发送资源，而无需客户端显式请求。
- **减少延迟**：由于只需一个TCP连接，HTTP/2减少了建立新连接所需的时间和资源。

综上所述，二进制分帧层是HTTP/2协议的核心组成部分之一，它通过引入帧、消息和流等概念，实现了对HTTP通信的高效管理和优化。



## **cookie 同源策略**

Cookie有两个很重要的属性:Domain和Path，用来指示此Cookie的作用域：

- domain字段为可以访问此cookie的域名，告诉浏览器当前要添加的Cookie的域名归属，如果没有明确指明则默认为当前域名，可以设置当前域名或者（`父域名必须以“.”开始，例如.xxx.com`）。为了保证安全性，cookie无法设置除当前域名或者其父域名之外的其他domain。

- path字段为可以访问此cookie的页面路径。如果没有明确指明则默认为当前路径，比如通过访问。 比如domain是abc.com,path是/test，那么只有/test路径下的页面可以读取此cookie，"/"表示根路径。

- 同源策略（Same-Origin Policy）：默认情况下，Cookie 受到同源策略的限制，即只有在同一域名、协议和端口的网页才能访问共享 Cookie。这意味着一个网站的 Cookie 通常无法被另一个不同域名的网站所访问。


- 域名限制：Cookie 的域名属性 (Domain) 决定了哪些域名可以访问该 Cookie。通常情况下，Cookie 的域名属性被设置为当前网页所在的域名，但可以通过明确设置域名属性来允许子域名之间共享 Cookie。

- 安全限制：对于带有 Secure 属性的 Cookie，浏览器要求它们只能通过安全的 HTTPS 连接传输，这有助于确保在传输过程中不会被窃取。因此，如果一个网页是通过 HTTP 加载的，那么它无法访问带有 Secure 属性的 Cookie。

- 路径限制：Cookie 的路径属性 (path) 可以限制哪些路径下的网页可以访问该 Cookie。通常情况下，Cookie 的路径属性被设置为当前网页的路径，但可以通过明确设置路径属性来限制访问。

- HttpOnly 属性：设置 Cookie 的 HttpOnly 属性可以禁止客户端 JavaScript 访问该 Cookie，以增加安全性，防止跨站点脚本攻击 (XSS)。

- 过期时间：Cookie 可以设置一个过期时间，一旦过期，浏览器将不再发送该 Cookie。这有助于确保敏感信息不会长时间存在于客户端。

- 限制数量：浏览器通常会限制每个域名下的 Cookie 数量和总大小，以防止滥用和过多的存储。

- SameSite 属性：SameSite 属性用于控制 Cookie 是否可以在跨站点请求中传递。通过设置 SameSite 属性，可以减少跨站点请求伪造 (CSRF) 攻击的风险。
  ————————————————
  版权声明：本文为CSDN博主「淮里没有猫」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
  原文链接：https://blog.csdn.net/qq_20470063/article/details/133032480

## 收到状态码200，一定经过网络传输吗，有其他case吗

本地缓存：如果之前的请求已经缓存了请求的响应，并且缓存仍然有效（未过期或未失效），客户端可以从本地缓存中获取响应，而不需要进行网络传输。这种情况下也可能收到状态码200，但没有实际的网络传输。

代理服务器缓存：在一些网络环境中，存在代理服务器（如CDN或反向代理服务器），代理服务器可以缓存响应并根据缓存策略返回响应。如果客户端的请求被代理服务器的缓存命中，客户端会收到状态码200，但代理服务器可能会根据自身的缓存策略返回缓存的响应，而不需要从原始服务器获取数据。
————————————————
版权声明：本文为CSDN博主「淮里没有猫」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_20470063/article/details/133032480**

## 移动端与pc端的区别

 PC考虑的是浏览器的兼容性

在布局上，移动端开发一般是要做到布局自适应的

## 有一个cookie种在www.toudiao.com，那在mp.toudiao.com能访问这个cookie吗，为什么

在默认情况下，Cookie 遵循同源策略（Same-Origin Policy），这意味着只有在同一域名、协议和端口的网页才能访问共享 Cookie。如果一个 Cookie 是在 www.toudiao.com 域名下设置的，那么它通常不会被 mp.toudiao.com 域名下的页面访问到。

这是因为域名 www.toudiao.com 和 mp.toudiao.com 在同源策略的定义下被认为是不同的域名，它们有不同的子域名（www 和 mp），因此 Cookie 不会自动在它们之间共享。

如果您希望在不同子域名之间共享 Cookie，您可以采取以下几种方法之一：

设置 Cookie 的 Domain 属性：当设置 Cookie 时，可以通过设置其 Domain 属性来指定哪些子域名可以访问该 Cookie。例如，您可以将 Domain 设置为 .toudiao.com，以使 Cookie 在所有 toudiao.com 子域名下都可用。

document.cookie = "name=value; Domain=.toudiao.com; path=/";

使用主域名：在设置 Cookie 时，可以使用主域名（例如 toudiao.com）而不是特定的子域名，这将使 Cookie 在所有子域名下都可用。

document.cookie = "name=value; Domain=toudiao.com; path=/";


## TCP HTTP

TCP（Transmission Control Protocol）和HTTP（Hypertext Transfer Protocol）是两个不同但密切相关的协议，它们一起构成了互联网通信的基础。

TCP（Transmission Control Protocol）：TCP是一种面向连接的、可靠的传输层协议。它负责在网络上可靠地传输数据，确保数据的完整性、有序性和可靠性。TCP建立了一个可靠的双向通信通道，通过三次握手建立连接，使用序号和确认号来跟踪数据的传输和接收。TCP提供了流量控制、拥塞控制和错误检测等功能，以确保数据能够可靠地从一个点传输到另一个点。TCP是一个底层协议，几乎所有的应用层协议都依赖于它来进行数据传输，包括HTTP。

HTTP（Hypertext Transfer Protocol）：HTTP是一种应用层协议，用于在互联网上传输超文本文档，通常用于在Web浏览器和Web服务器之间传递HTML页面、图像、视频、音频和其他资源。HTTP是基于TCP协议的，它使用TCP连接来传输数据。当您在Web浏览器中输入一个URL并请求一个网页时，浏览器会使用HTTP来与Web服务器进行通信，发送HTTP请求并接收HTTP响应，然后在浏览器中呈现网页内容。

简而言之，HTTP是应用层协议，它建立在TCP协议之上，用于在客户端和服务器之间传输Web内容。TCP负责在网络上传输数据的可靠性，而HTTP负责定义如何组织和传递数据，以便在Web上呈现内容。这两个协议一起构成了Web通信的基础架构。
————————————————
版权声明：本文为CSDN博主「淮里没有猫」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_20470063/article/details/133032480

## 除了API请求之外, 从前端把信息上报给后端还有哪些途径

**WebSocket**：实时双向通信。

**Server-Sent Events (SSE)**：服务器推送事件。

**Web Workers / Service Workers**：后台线程处理数据或网络请求。

**Beacon API**：在页面卸载时无阻塞地上报数据。专门用于发送少量数据的 API，支持 POST 请求，且不会阻塞页面卸载。

**GraphQL Subscriptions**：基于 GraphQL 的实时数据推送。

**Long Polling**：模拟实时推送的长时间 HTTP 请求。

**File Upload (FormData)**：通过表单数据上传文件或信息。

**HTTP/2 Push**：服务器主动推送资源或数据。

## 前端常用的几种请求方式

## **XMLHttpRequest（XHR）**

XMLHttpRequest 是前端最早使用的数据请求方式。它支持异步请求，可以通过设置回调函数处理请求完成后的数据。

### **性能：XHR 在较早的浏览器中表现良好，但随着浏览器性能的提升，其性能瓶颈逐渐凸显。相较于其他请求方式，XHR 的性能稍逊一筹。**



## **Fetch**

Fetch 是一个现代的、基于 Promise 的 HTTP 客户端，用于浏览器和 Node.js。它提供了一种更简洁、更易于理解的方式来处理网络请求。

### **性能：Fetch 在现代浏览器中性能较好，相较于 XHR 有所提升。**



## **Axios**

Axios 是一个基于 Promise 的 HTTP 客户端，用于浏览器和 Node.js。它扩展了 Fetch API，提供了更丰富的功能。

### **性能：Axios 在现代浏览器中性能较好，与 Fetch 相当。**



| 特性/方式     | XMLHttpRequest                 | Fetch API                    | Axios                                | WebSocket                                |
| ------------- | ------------------------------ | ---------------------------- | ------------------------------------ | ---------------------------------------- |
| 执行速度      | 中等                           | 快                           | 快                                   | 非常快（长连接）                         |
| 内存使用      | 中等                           | 低                           | 低                                   | 低（长连接）                             |
| 兼容性        | 旧浏览器可能需要 ActiveXObject | 新浏览器                     | 新浏览器，旧浏览器需要 polyfill      | 新浏览器，旧浏览器需要 polyfill          |
| 易用性        | 复杂的 API，基于回调           | 简洁的 API，基于 Promise     | 简洁的 API，基于 Promise，提供拦截器 | 简单的 API，但需要处理连接管理和消息格式 |
| 功能特性      | 事件驱动，支持同步请求         | 基于 Promise，不支持同步请求 | 丰富的配置，拦截器，自动转换 JSON    | 实时双向通信，不支持 HTTP 请求方法       |
| 跨域请求      | 需要服务器支持 CORS            | 默认支持 CORS                | 默认支持 CORS                        | 需要服务器支持 CORS                      |
| 取消请求      | 支持 abort 方法                | 结合 AbortController 使用    | 结合 AbortController 使用            | 通过关闭连接取消                         |
| 自动转换 JSON | 不支持                         | 支持                         | 支持                                 | 不支持，需要手动处理                     |

## ajax的callback 和fetch的.then那个更早?

### 1. **AJAX 的 Callback**

AJAX（Asynchronous JavaScript and XML）通常通过 `XMLHttpRequest` 对象实现。它的回调函数是通过 `onreadystatechange` 或 `onload` 等事件触发的。

#### 执行时机：

- 当 AJAX 请求完成（即 `readyState` 变为 `4` 且状态码为 `200`）时，浏览器会将回调函数放入 **任务队列（Task Queue）** 中。
- 在事件循环的下一个周期，主线程会从任务队列中取出回调函数并执行。

### 2. **Fetch 的 `.then`**

`fetch` 是基于 Promise 的 API，它的 `.then` 回调是通过 **微任务队列（Microtask Queue）** 调度的。

#### 执行时机：

- 当 `fetch` 请求完成时，浏览器会将 `.then` 的回调放入 **微任务队列** 中。
- 在当前事件循环的末尾（即当前任务执行完毕后），主线程会清空微任务队列，执行 `.then` 回调。

在 JavaScript 的事件循环中，任务队列和微任务队列的执行顺序如下：

1. **同步代码**：优先执行所有同步代码。
2. **微任务队列**：在当前任务执行完毕后，清空微任务队列（包括 Promise 的 `.then` 回调）。
3. **任务队列**：在微任务队列清空后，从任务队列中取出下一个任务执行（包括 AJAX 的回调）。

## promise.then的调度?事件循环解决什么问题?

`Promise` 的执行流程如下：

1. **异步执行**：当我们调用 `Promise.then()` 或者 `.catch()` 时，实际上这些回调并不会立刻执行。相反，它们会被放入 **微任务队列** 中。

2. **微任务队列**：微任务队列的优先级高于宏任务队列，所有微任务会在当前宏任务执行完之后、浏览器渲染之前被执行。

3. 事件循环

   ：事件循环的工作原理是：

   - 执行当前栈中的同步代码（当前宏任务）。
   - 然后执行微任务队列中的任务，直到微任务队列为空。
   - 最后执行宏任务队列中的任务，并重新进入下一个事件循环周期。

###### 

#### 事件循环的作用：

1. **非阻塞 I/O**：传统的同步编程模型中，如果某个任务需要等待（比如 I/O 操作或网络请求），其他任务就会被阻塞，直到当前任务完成。JavaScript 使用事件循环解决了这个问题，即使在单线程中也能够高效地处理并发操作，通过异步任务避免阻塞主线程。
2. **执行顺序的管理**：事件循环决定了同步任务和异步任务（如回调、`setTimeout`、`Promise` 等）何时执行。它确保：
   - 同步任务优先执行。
   - 异步任务（例如 `Promise.then`）在当前宏任务执行完之后尽早执行，而 **微任务**（如 `Promise.then`）总是优先于宏任务执行。

## 知道“流”吗，这可以让GPT更快地返回内容

在 Web 开发中，“流”（Streams）指的是一系列按顺序传输的数据块，它们是以连续、分块的方式传输的，而不是一次性加载全部数据。流是处理大量数据（如大文件下载、视频流或持续的 API 响应）时非常有效的一种方法，它可以避免占用过多的内存。

#### **流的类型**：

1. **Readable Streams**： 读取数据流（如响应体、文件读取等），它允许逐步读取数据。
2. **Writable Streams**： 写入数据流（如上传文件、通过网络发送数据等）。
3. **Transform Streams**： 在数据通过流传输时，进行转换或处理的流。
4. **Duplex Streams**： 可同时进行读写操作的流（如 WebSockets）。

### **流的实际应用：**

1. **大文件上传与下载**：
   - 通过 `ReadableStream` 和 `WritableStream`，可以逐步上传或下载文件，避免了内存中存储整个文件的需求。
2. **实时数据传输**：
   - 如实时聊天应用、视频流媒体、游戏数据等。流技术可以使数据在传输的同时被处理和渲染。
3. **多媒体应用**：
   - 视频、音频的逐步加载与播放都能通过流来实现，视频播放时可以一边下载一边播放，减少了加载时间。



# CSS

## 盒子模型

标准：会被撑大，content-box，往外加

怪异：内容压缩小了，border-box，往里挤压

## 手写三栏布局

## 优先级的计算规则

内联 > ID选择器 > 类选择器 > 标签选择器。



## 元素分类

在CSS中，元素大致可以分为以下几种：

### 1.块级元素（Block-level Elements）：

这些元素以块的形式显示在页面上，**每个块级元素会独占一行**（除非通过其他CSS属性进行修改）。 块级元素可以设置宽度、高度、内边距和外边距。 一些常见的块级元素包括`<div>, <p>, <h1>-<h6>, <ul>, <li>, <section>, <footer>`等。

### 2.行内元素（Inline Elements）：

**行内**元素也称为**内联**元素，这些元素以行内的形式显示在页面上，它们不会独占一行，而是在同一行上与其他元素并排显示。 行内元素的宽度和高度默认由其内容决定，**无法设置宽度和高度**还有间距。 一些常见的行内元素包括`<span>, <a>, <strong>, <em>, <img>, <input>`等。

### 3.行内块元素（Inline-block Elements）：



现实中的网页（如豆瓣），很多内容块都是拼接的，如果我们使用块状元素来表示这些内容块，如果消除它独占一行的情况呢？

这些元素以行内块的形式显示在页面上，具有行内元素的特性，但可以设置宽度、高度、内边距和外边距。 行内块元素会在同一行上显示，但它们之间会保留空白间隔。 一些常见的行内块元素包括` <button>, <label>, <select>, <textarea>, <img>` 等。



作者：牛哥说我不优雅
链接：https://juejin.cn/post/7234337275345387581
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 自适应矩形

1、使用 **百分比+padding**，这里有一个很细的知识点；**当padding、margin取值为百分比时，百分比的值是以父元素的width为参考**。

​	  我们给盒子的宽度设置20%，使用的padding的**纵轴**将盒子高度撑开，这样便得到了一个自适应正方形。

```css
.card-box {
    width: 25%;
    height: 0;
    padding-bottom: 25%;
    position: relative;
}

.card {
    position: absolute;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
    background-color: skyblue;
}
```

2、**rem**、**vw**等相对单位，我们分别用这些单位来实现一下

3、使用aspect-ratio属性

## 居中

### text-align: center

- **适用于内联元素，而不适用于块级元素**
- 这是一种简单而常用的方法，特别适用于文本、按钮、图标等内联元素的水平居中。然而，它**只能实现水平居中**，对于垂直居中需要采用其他的布局方法
- 若元素是单行文本, 则可设置 **line-height 等于父元素高度**来实现垂直居中。

## css中 top, right, bottom, left设置为0有什么用？它和width:100%和height:100%有什么区别？

##### 让明确宽高的盒子垂直水平居中

通过设置top，left四属性为0居中元素的做法有个前置条件，就是`需要居中的盒子必须有固定的宽高(px)`，否则会失效。这就像**四个方向有相同的力在拉这个盒子，`配上margin:auto让这个盒子的位置保持中立`，来达到盒子处于正中心的目的**。

##### 让无宽高的盒子填满父容器

在做弹窗或者loading效果时，我们往往会给弹窗加一个半透明的黑色遮罩，用于凸显核心内容；当父容器宽高不确定时，遮罩的宽高也无法确定，除了设置width:100%，height:100%外，设置top，right四属性为0就是第二做法。

设置top:0，left:0，right:0，bottom:0本质目的，是让子盒子四边与父容器间距为0，而子盒子没有明确宽高，自然被拉伸到完全填满父容器了

## css变量



## css选择题优先级



## dom事件模型，事件机制



## 捕获或者冒泡可以被中断吗？（会）什么情况下会去做中断？（？找不到具体场景）

## 分析下 flex: 0 1 auto；代表什么？

flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。

- flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。
- flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。
- flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间（main size）。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。
- **`flex-grow: 0`**：该项 **不会增长**，即使有剩余空间。

  **`flex-shrink: 1`**：该项 **会收缩**，如果容器空间不足，它可以收缩。

  **`flex-basis: auto`**：该项的 **初始大小由其内容的自然大小决定**。

## CSS 中的伪类和伪元素

CSS 引入伪类和伪元素的概念是为了实现基于文档树之外的信息的格式化

伪类和选择器之间用**一个冒号隔开**，伪元素则是**两个冒号隔**

1、伪类  hover和active
概念：为处于某个状态的已有元素添加对应的样式，这个状态是根据用户行为而动态改变的。

它可以用于

设置鼠标悬停在元素上时的样式
为已访问和未访问链接设置不同的样式
设置元素获得焦点时的样式
2、伪元素 
概念：创建一些不在文档树中的元素，并为其添加样式。(就是选取某些元素前面或后面这种普通选择器无法完成的工作,虽然用户可以看到这些文本，但是这些文本实际上不在文档树中。)

first-child last-child nth-child **给div的第一个或者最后一个子元素添加样式**。

**before 和 after**是经常经常重用的伪元素。

**伪元素虽然是不存在于DOM树种的元素，但是也是可以添加内容的，就是上面提到的content属性。content属性可以是URL、字符串甚至是图片，视频等**

它可以用于

设置元素的首字母、首行的样式
在元素的内容之前或之后插入内容

## 浏览器的渲染原理

1.浏览器解析html的流程分为三步

第一首先拿到这个字符串的html,并且再次开一个线程，叫做**预解析线程**，因为下载解析css也是会需要时间的，如果都放在主线程来做会有时间忧虑，为了提高效率所以先开始预解析进程帮助渲染主线程进行**css的预下载和解析，解析好了返给渲染主线程，让主线程**
**去生成cssom，这就是css不会阻塞html的根本原因**。

第二当碰到js文件的时候浏览器会怎么做呢，他会先暂停浏览器的一切行为，等待预解析线程给返回提前下载好的js，js也是预解析线程提前下载的，如果主线程解析到`script`位置，会停止解析 HTML，转而等待 JS 文件下载好，并将全局代码解析执行完成后，才能继续解析 HTML。这是因为 JS 代码的执行过程可能会修改当前的 DOM 树，所以 DOM 树的生成必须暂停。这就是 JS 会阻塞 HTML 解析的根本原因。

最后解析完成后，会得到 **DOM 树和 CSSOM 树**，浏览器的默认样式、内部样式、外部样式、行内样式均会包含在 CSSOM 树
中。

**解析 HTML** → **生成 DOM 树**

```
html
 ├── head
 │    └── title
 └── body
      └── div.container
          └── h1

```

**解析 CSS** → **生成 CSSOM 树**

```
CSSOM
 ├── .container { margin: 0 auto; padding: 20px; }
 └── h1 { color: blue; }

```

2.样式计算

第一步我们拿到了生成的DOM 树和 CSSOM 树，这一步就是要对DOM 树中每个节点中有什么信息进行 计算，这一过程中，很多预设值会变成绝对值，比如`red`会变成`rgb(255,0,0)`；相对单位会变成 绝对单位，比如`em`会变成`px`,这一步完成后，会得到一棵带有计算后样式的 DOM 树。

构建渲染树

1. 过滤掉不可见的元素
2. 计算样式

```
render tree
 ├── div.container (with computed styles: margin: 0 auto, padding: 20px)
 └── h1 (with computed styles: color: blue)

```

3.布局  Reflow



根据上一步提供的样式计 算出他的当前位置节点在哪  它会为每个渲染树节点计算一个 **矩形区域**，即它们的位置和大小。

4.绘制  Paint

这个步骤将渲染树中的每个元素转换为屏幕上的像素，涉及到绘制文本、图像、颜色、边框等。

绘制过程中，浏览器会将每个渲染树节点转换为 **层**（layer），这些层会被提交到 **合成线程**（compositor thread）进行最终的渲染。



## 浮动

**父元素的高度由最后一个非浮动子元素的占位空间所决定。**

① 浮动元素会脱离标准流；
② 浮动元素会在一行内显示，并沿着元素的顶部对齐；
③ 浮动元素会具有[行内块元素](https://so.csdn.net/so/search?q=行内块元素&spm=1001.2101.3001.7020)的特性。

1.文字环绕

2.浮动可以让块级元素同行显示

3.元素脱离文档流，父容器的高度塌陷

4.浮动元素可以让行内元素可以设置宽高

5.浮动元素可以设置margin，但是不能用margin:0 auto居中；

子元素div并没有撑开父容器，这就是我们要清除浮动的原因

#### 清除浮动

#### 1. 利用clear样式

- **让父亲包裹浮动子元素，减少对其他元素的影响**

![浮动效果](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/18/2af797ffc0918352ac8d381994ff1a27~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)

![img](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2017/10/18/23e815f13d70590629b3a9d2020b955b~tplv-t2oaga2asx-zoom-in-crop-mark:4536:0:0:0.image)

通过上面的样式，`.textDiv`告诉浏览器，我的左边不允许有浮动的元素存在，请清除掉我左边的浮动元素。然而，因为浮动元素（`.floatDiv`）位置已经确定，浏览器在计算`.textDiv`的位置时，为满足其需求，将`.textDiv`渲染在浮动元素下方，保证了`.textDiv`左边没有浮动元素。同时可以看出，父元素的高度也被撑起来了，其兄弟元素的渲染也不再受到浮动的影响，这是因为`.textDiv`仍然在文档流中，它必须在父元素的边界内，父元素只有增加其高度才能达到此目的，可以说是一个意外收获。(`clear`的值为`both`也有相同的效果，通俗理解就是，哪边不允许有浮动元素，clear就是对应方向的值，两边都不允许就是`both`)

我们发现父元素的高度等于浮动元素的占位空间。

`clear: left;` 就是让左浮动元素持有占位空间

让我们再来拓展一下，`clear` 除了可以设置为 `left`，还可以设置为 `right` 和 `both`。

`right` 就是让右浮动元素持有占位空间。

`both` 就是让两边的浮动元素都持有占位空间。



作者：ScalaCool
链接：https://juejin.cn/post/6844903560644313101
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

#### 2. 父元素结束标签之前插入清除浮动的块级元素

清除浮动和撑起父元素高度其实是两个不同的问题

在父级元素末尾添加的元素必须是一个**块级元素**，撑起父级元素高度

*// 区别在这里* .blankDiv {    clear: both; *// or left* }

#### 3. 利用伪元素（clearfix）

```css
// 省略基本的样式
// 区别在这里
//在标准浏览器下，.clearfix:after 这个伪类会在应用到 .clearfix 的元素后面插入一个 clear: both 的块级元素，从而达到清除浮动的作用。
.clearfix:after {
    content: '.';
    height: 0;
    display: block;
    clear: both;
}

.clearfix {
  zoom: 1;//在IE6, 7下 zoom: 1 会触发 hasLayout，从而使元素闭合内部的浮动。
}
```



#### 4. 利用overflow清除浮动

仅仅只在父级元素上添加了一个值为auto的overflow属性，父元素的高度立即被撑起，将浮动元素包裹在内。看起来，浮动被清除了，浮动不再会影响到后续元素的渲染（严格讲，这和清除浮动没有一点关系，因为不存在哪个元素的浮动被清除，不纠结这个问题）

当元素设置了`overflow`样式，且值不为`visible`时，该元素就建构了一个BFC(哪些情况下，元素可以建构出BFC，可以看查看CSS文档对[BFC的定义](https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FTR%2FCSS2%2Fvisuren.html%23block-formatting))。在我们的例子中，`.topDiv`因设置了值为`auto`的`overflow`样式，所以该元素建构出一个BFC，按照第三个特点，BFC的高度是要包括浮动元素的，所以`.topDiv`的高度被撑起来，达到了清除浮动影响的目的

块格式化上下文（BFC）有下面几个特点：

1. BFC是就像一道屏障，隔离出了BFC内部和外部，内部和外部区域的渲染相互之间不影响。BFC有自己的一套内部子元素渲染的规则，不影响外部渲染，也不受外部渲染影响。
2. BFC的区域不会和外部浮动盒子的外边距区域发生叠加。也就是说，外部任何浮动元素区域和BFC区域是泾渭分明的，不可能重叠。
3. BFC在计算高度的时候，内部浮动元素的高度也要计算在内。也就是说，即使BFC区域内只有一个浮动元素，BFC的高度也不会发生塌缩，高度是大于等于浮动元素的高度的。
4. HTML结构中，当构建BFC区域的元素紧接着一个浮动盒子时，即，是该浮动盒子的兄弟节点，BFC区域会首先尝试在浮动盒子的旁边渲染，但若宽度不够，就在浮动元素的下方渲染。[[看这里\]](https://link.juejin.cn?target=https%3A%2F%2Fwww.w3.org%2FTR%2FCSS2%2Fvisuren.html%23bfc-next-to-float)

这个例子中，选用`inline-block`和选用`overflow`效果完全一样，没有看出有什么副作用，但不代表在其他项目中一样能行得通。甚至对`overflow`值的选择也要考虑其表现和影响。在各种构建BFC的方式中，`overflow`方式可能是外部影响更可控的一种，我猜想这也许就是为什么普遍采用`overflow`来清除浮动的原因吧。



## css counters 的属性

- counter-reset  在目标元素所在的层级中定义一个计数器
- counter-increment  当浏览器渲染页面时，带这个属性的元素每出现一次，当前层级内对应名字的计数器就增加相应的值。如不写，默认是 1
- counter() / counters() counter() 和 counters() 就负责把计数器显示出来。这两个计算方法要和伪元素的 content 属性搭配食用。形如：`content: counter(level1)`。counter 计算符前后可以随意加字符串来对最后的效果做拼接。



## 垂直水平居中

margin:auto

**position:absolute**  transform: translate(-50%, -50%);

display: flex 

text-align: center;



## 绝对定位

**position 属性指定了元素的定位类型，** **用于指定一个元素在文档中的定位方式**

相对定位：position : relative
在相对定位中，定位元素是根据自己原本所在位置进行定位，相对定位不会脱离文档流，在文档流中不会影响其他元素，偏移量根据给定的值，值可以为负数；

-   top  数值越大越往下  顶部与原位置差

-   bottom 数值越大越往上  底部与原位置差
-   left 数值越大越往右  左边与原位置差
-   ight 数值越大越往左  右边与原位置差

 特点    占原位置，在文档流中占位置。

绝对定位 ：position:absolute
绝对定位中，定位依据是定位元素的父级，直到找到body元素，绝对定位的元素会脱离文档流，行内可以设置宽高，块元素不独占一行，由内容撑开宽高；

- top  数值越大越往下  顶部与定位父级的顶部之差
- bottom 数值越大越往上  底部与定位父级的底部之差
- left 数值越大越往右  左边与定位父级的左边之差
- right 数值越大越往左  右边与定位父级的右边之差

特点  脱离文档流 
固定定位：position:fixed
根据浏览器窗口的位置和大小进行定位，元素的位置在屏幕内容滚动时不会改变位置，固定定位的元素会移出文档流；

top 根据窗口的上边进行定位
bottom 根据窗口的下边进行定位
left 根据窗口的左边进行定位
right 根据窗口的右边进行定位

### position 的主要属性

1. **static**：默认值。元素按照正常的文档流进行布局，即元素的位置由其在HTML文档中的位置决定。
2. **relative**：相对定位。元素首先按照正常文档流进行布局，然后可以通过设置`top`、`right`、`bottom`、`left`属性相对于其正常位置进行偏移。
3. **absolute**：绝对定位。元素从文档流中脱离，并相对于其最近的已定位（即非static）祖先元素进行定位。如果没有这样的祖先元素，则相对于初始包含块（通常是`<html>`元素，即视口或页面本身）进行定位。
4. **fixed**：固定定位。元素从文档流中脱离，并相对于浏览器窗口进行定位。即使页面滚动，它也会停留在固定位置。
5. **sticky**：粘性定位。元素根据用户的滚动位置在相对定位和固定定位之间切换。它的行为依赖于`top`、`right`、`bottom`、`left`属性的值。

`position` 属性的 `absolute` 和 `fixed` 有以下主要区别：

**`absolute`** 参照物是可以设置的，它相对于最近的已定位父元素（即设置了 `position` 属性且值不为 `static` 的元素）进行定位。当页面滚动时，`absolute` 定位的元素会随其已定位的父元素一起滚动。

**`fixed`** 参照物固定是浏览器窗口，即相对于视口（viewport）进行定位。即使页面滚动，`fixed` 定位的元素也会始终位于同一位置。

- `absolute` 和 `fixed` 定位的元素都会脱离正常的文档流，即它们不再占据文档中的空间，其他元素会忽略它们的存在进行布局。

### 绝对布局和相对布局

- **绝对布局（absolute）**：元素的位置是相对于其最近的已定位（非static）祖先元素。如果所有祖先元素都是`static`的，则相对于初始包含块（通常是`<html>`元素）定位。
- **相对布局（relative）**：元素的位置是相对于它在正常文档流中的原始位置进行偏移。即，元素仍然保留在文档流中，但是可以通过设置`top`、`right`、`bottom`、`left`属性来改变其最终位置。

### 父元素与子元素的布局关系

- 当父元素的`position`是`relative`或`absolute`（或其他非static值）时，子元素的`position`为`absolute`，那么子元素将相对于该父元素进行定位。
- 如果父元素没有设置`position`（即默认为`static`），并且所有祖先元素也都是`static`的，那么子元素的`position: absolute;`将相对于`<html>`元素（初始包含块）进行定位。



## 移动端适配



## 渲染步骤涉及到三个阶段：

- **样式（S）：** 负责样式计算，收集所有的 CSS、计算机应用到元素上的样式
- **布局（L）：** 创建一个渲染树，找到页面上的所有内容以及元素的位置
- **绘制（P）：** 创建实际的像素数据，绘制内容到页面上

## HTML语义化

HTML语义化是指使用恰当的HTML标签来描述网页内容的结构和含义，而不仅仅是为了样式和布局而使用标签。合理使用语义化标签有助于提高网页的可访问性、可读性和SEO优化。**避免过度使用无语义的`<div>`和`<span>`标签**

`<header>`标签表示网页的顶部区域

`<h1>`标签表示页面的主标题

`<nav>`标签表示导航菜单

`<ul>`和`<li>`标签表示列表项

`<a>`标签表示链接

`<main>`标签表示页面的主要内容区域

`<section>`标签表示每个章节

`<h2>`标签表示每个章节的标题

`<footer>`标签表示页面的脚注部分

`<p>`标签表示段落内容

## 硬件加速

硬件加速，直观上说就是依赖 GPU 实现图形绘制加速，软硬件加速的区别主要是图形的绘制究竟是 GPU 来处理还是 CPU，如果是 GPU，就认为是硬件加速绘制，反之，则为软件绘制。

一般一个元素开启硬件加速后会变成复合图层，可以独立于普通文档流中，改动后可以避免整个页面重绘，提升性能。

常用的硬件加速方法有：

- 最常用的方式：`translate3d`、`translateZ`
- `opacity` 属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）
- `will-change`属性（这个知识点比较冷僻），一般配合 `opacity` 与 `translate` 使用（而且经测试，除了上述可以引发硬件加速的属性外，其它属性并不会变成复合层），作用是提前告诉浏览器要变化，这样浏览器会开始做一些优化工作（这个最好用完后就释放）
- `<video>`、`<iframe>`、`<canvas>`、`<webgl>`等元素
- 其它，譬如以前的 `flash` 插件

当然，有的时候我们想强制触发硬件渲染，就可以通过上面的属性，比如



作者：前端时代周刊
链接：https://juejin.cn/post/7097026594220277767
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 如何判断一个元素是否在可视区域？

### 通过元素的位置信息和滚动条滚动的高度来判断

```
function isContain(dom) {
    // 获取可视窗口的盖度。
    const screenHeight = window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight;
    // 获取滚动条滚动的高度
    const scrollTop = document.documentElement.scrollTop;
    // 获取元素偏移的高度。就是距离可视窗口的偏移量。
    const offsetTop = dom.offsetTop;
    return offsetTop - scrollTop <= screenHeight;
}

```

### getBoundingClientRect

他是dom对象的一个方法。返回一个DOMRect对象。该对象拥有`left`, `top`, `right`, `bottom`, `x`, `y`, `width`, 和 `height`属性。

当页面发生滚动的时候，`top`, `left`, `right`, `bottom`属性值都会随之改变。

### webAPI，Intersection Observer来实现监听

- **`getBoundingClientRect()`**：简单易用，适合大多数场景。但需要注意的是，当页面发生滚动或调整大小时，需要重新计算元素的边界。
- **`Intersection Observer API`**：性能更优，特别是在需要监视多个元素时。它提供了一种异步的方式来处理元素的可见性变化，避免了对主线程的频繁占用。
- **`offsetTop` 和 `scrollTop`**：这种方法较为基础，但在处理复杂布局时可能不够准确。它只考虑了垂直方向上的可见性，没有考虑水平方向。

## png,jpg/jpeg,gif,webp这些图片格式解释一下，分别什么时候用？

png:无损压缩，尺寸体积要比jpg/jpeg的大，比较适合用于制作小图标。**PNG图片支持无损压缩，但其压缩比有上限，这种格式的图片支持无损压缩，能够被编辑，它适合用来做透明图、小图标、背景图等，但占用的存储空间比较大。**
jpg:采取压缩算法，有一些失真，比png的体积要小，适合制作中大图片。JPG图片支持最高级别的压缩，体积小方便储存和传输，但它在生成时就是有损的，会使原始图片数据质量下降。JPG格式可以精确控制压缩比，对图片的色彩信息保留较好，能减少图像的传输时间，适合用于存储图片。
gif:一般用于制作动态图片，

webp:这个我们在网页上直接下载的很多都是这种图片，它是同时支持有损或者无损压缩，同质量的图片，webp具有更小的体积，兼容性不是特别的好。而Webp是google推出一种图片格式，它的特点就是支持无损或有损压缩，图像体积很小。相同画质下，[无损WebP](https://www.zhihu.com/search?q=无损WebP&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2734465866})相比PNG减少26%大小，[有损Webp](https://www.zhihu.com/search?q=有损Webp&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={"sourceType"%3A"answer"%2C"sourceId"%3A2734465866})在相同的SSIM下比JPE减少25%~34%的大小。对于使用大量图片的网站，Webp图片可以减少流量耗费和加载时间，所以很多网站会使用Webp格式的图片，减少流量耗费和加载时间。

当 WebP 将 JPG 压缩到相当于原图 90% 质量 时，图片体积减少了 50% 左右。当 WebP 将 JPG 压缩到相当于原图 80% 质量时，图片体积则减少了 60%~80%。

| 格式 | 特点                                                         | 适用场景                               |
| ---- | ------------------------------------------------------------ | -------------------------------------- |
| JPG  | 压缩率高，加载速度快，但质量易受损                           | 网络传输、网页图片                     |
| PNG  | 无损压缩，图像质量高，文本清晰，可保留透明度，但文件较大     | 需要高质量图像和透明背景的场合         |
| GIF  | 适合动画展示，容量小，支持透明度，但质量较差，不支持24bit彩色 | 动画效果、简单图像展示                 |
| TIFF | 常用于印刷，支持多图层和透明度，无损压缩，但文件大，打开慢   | 高质量图像打印和出版                   |
| PSD  | Photoshop专用，无损质量，支持全色彩模式，但文件大，需特定软件打开 | Photoshop编辑和创作                    |
| EPS  | 通用可交换文件格式，无损缩放，但文档大，不适合网页加载       | 矢量图形和印刷                         |
| SVG  | 可缩放矢量图形，文件大小相对较小，可编辑性和交互性           | 2D图形设计、网络矢量图形               |
| WEBP | 有损和无损压缩格式，文件更小，但设计软件中不能直接编辑       | 网络传输、网页图片（追求更小文件大小） |

## SVG与Canvas的区别

SVG和Canvas是两种不同的绘图技术，它们在多个方面存在显著差异：

1. **绘图语法**：
   - SVG使用XML来绘制图形，通过定义各种图形元素（如圆形、矩形、直线等）及其属性（如颜色、位置、大小等）来构建图像。
   - Canvas则使用JavaScript和HTML元素来绘制图形，通过调用Canvas API提供的绘图方法（如绘制路径、矩形、圆等）来绘制图像。
2. **绘图原理**：
   - SVG通过DOM节点渲染图形，每个图形元素都是一个DOM节点，因此SVG图像可以很容易地进行编辑和修改。
   - Canvas通过像素渲染图形，它使用位图技术来绘制图像，因此Canvas图像在放大或缩小时可能会出现失真。
3. **性能**：
   - 如果SVG的节点过多，会导致渲染速度变慢，因为浏览器需要处理大量的DOM节点。
   - Canvas的性能通常更好，因为它直接操作像素数据，不需要处理DOM节点。然而，Canvas在绘制复杂图形时可能需要更多的计算资源。
4. **分辨率**：
   - SVG不依赖分辨率，因此无论图像大小如何变化，都不会出现失真。这使得SVG非常适合用于需要高质量图像放大的场合。
   - Canvas依赖分辨率，因此当图像被放大或缩小时，可能会出现失真。为了避免失真，通常需要在绘制时选择合适的分辨率。
5. **支持事件**：
   - SVG支持分层和事件处理，因此可以很容易地为图像中的不同部分添加交互效果。
   - Canvas不支持事件处理，因为它是一个位图容器，无法直接对图像中的元素进行交互。然而，可以通过在Canvas上方放置透明的SVG或HTML元素来实现交互效果。



## 移动端响应式策略，rem原理，简单写一下 fexible 这个文件

`rem`的单位是相对于根元素（`<html>`标签）的字体大小来计算的，改变根元素的字体大小可以快速实现不同屏幕尺寸的适配。

在这个过程中，`flexible` 是一种常用的解决方案，通常用于动态计算和设置根元素的字体大小，基于设备的屏幕宽度来调整布局，使得页面在不同屏幕上都能良好显示。

flexible库的作用是什么呢 ， 让html的fontsize进行随着屏幕的宽度大小变化而变化， flexible库内部进行换算：屏幕宽度/10=html的fontsize

```js
(function (win, doc) {
  // 设置基准值，默认750宽度，适应750px的设计稿
  var docEl = doc.documentElement;
  var resizeEvt = 'orientationchange' in win ? 'orientationchange' : 'resize';
  var recalc = function () {
    var clientWidth = docEl.clientWidth;
    if (!clientWidth) return;
    // 设定基准设计稿的宽度为750px，根元素字体大小根据窗口宽度来动态计算
    docEl.style.fontSize = clientWidth / 7.5 + 'px'; // 750px -> 100px => 1rem = 100px / 7.5
  };

  // 初始化设置
  recalc();
  // 监听窗口的变化，重新计算字体大小
  win.addEventListener(resizeEvt, recalc, false);
})(window, document);

```

## 如何兼容浏览器，postcss用过哪些插件;

**使用前缀**：一些CSS属性或JavaScript特性在不同浏览器上有不同的实现方式，可以通过添加厂商前缀来确保兼容性。例如，CSS的 `-webkit-`、`-moz-`、`-ms-` 等前缀。

**使用Polyfill**：在一些不支持新特性的浏览器中通过Polyfill来填充缺失的功能。

**CSS Reset或Normalize**：确保不同浏览器有统一的样式基础，避免样式差异导致的兼容性问题。比如常用的 normalize.css。

**条件注释**：用于IE浏览器的特定版本的HTML条件注释，来加载不同的样式或脚本。

PostCSS 是一个CSS处理工具，它可以通过插件来实现不同的功能。常用的PostCSS插件有：

- **autoprefixer**：自动为CSS属性添加浏览器前缀，支持最新的浏览器兼容。
- **postcss-preset-env**：将现代CSS转换为兼容旧版浏览器的CSS。
- **cssnano**：用于压缩CSS，优化文件大小。
- **postcss-import**：使CSS文件可以像JS模块一样导入其他CSS文件。
- **postcss-mixins**：允许在CSS中使用类似于Sass的mixins。

## 如何兼容js，除了babel的其他方法;

#### **1. 使用Polyfill**

Polyfill 通过模拟新API，允许不支持该功能的浏览器正常运行。例如：ES6的`Promise`，`Object.assign`，`Array.prototype.includes`等功能可以通过引入相应的polyfill来兼容旧浏览器。

#### **2. 使用Transpilers和工具**

除了Babel，还可以使用其他的transpilers，如TypeScript或者ESLint，这些工具可以帮助你写出兼容性更强的代码，尤其是在TypeScript中，开发者可以使用严格类型检查来避免一些兼容性问题。

#### **3. 使用工具库（如Polyfill.io）**

`polyfill.io` 是一个CDN服务，它会根据浏览器的User-Agent动态加载所需的polyfill。这个工具可以自动为你加载缺失的Polyfill，而不用手动指定。

## 简单讲下 babel 做了哪几个层面的优化，用过 babel做过什么;

#### **1. 语法转换（Syntax Transformation）**

Babel 会将新版本的 JavaScript 代码（如ES6+）转换为较老版本的代码，以确保兼容旧浏览器。例如，将 `let` 转换为 `var`，将箭头函数转换为普通函数。

#### **2. polyfill**

Babel 本身并不直接引入 polyfill，但可以结合 `@babel/preset-env` 来自动引入需要的polyfill。比如使用 `core-js` 来支持新特性的兼容。

#### **3. 转换 ES6+ 语法特性**

- **箭头函数**：转换为普通的函数表达式。
- **类（Class）**：转换为基于原型的实现。
- **模块化（Modules）**：转换为 CommonJS 或 AMD 模块。
- **async/await**：转换为生成器函数和Promise链。
- **模板字符串**：转换为字符串拼接。

#### **4. Tree Shaking & Dead Code Elimination**

通过分析代码中的模块依赖关系，移除无用代码。这种优化常见于打包工具中，如Webpack。

## 了解过 polyfi 的原理吗，举个开发中使用 polyfill 的具体例子

#### **原理**

1. **检测浏览器环境**：通过 `window` 或 `document` 对象判断浏览器是否支持某些特性。
2. **加载Polyfill代码**：如果浏览器不支持某个特性，则将对应的Polyfill代码加载到页面中。
3. **使用Polyfill**：Polyfill 通过实现浏览器原生不支持的 API（如 `Promise`、`fetch`）来提供对应的功能。

例如，假设我们要使用 `Promise` 这个ES6新特性，但某些旧版浏览器不支持 `Promise`。我们可以通过加载 Polyfill 来解决：

```js
<script src="https://cdn.polyfill.io/v3/polyfill.min.js?features=Promise"></script>

```



## z index值大就一定会展示吗

### 排查步骤

1. **检查父级元素的 `z-index` 和堆叠上下文**。
2. **确认目标元素的 `position` 属性已设置**。
3. **查看其他元素是否遮挡了目标元素**。
4. **使用开发者工具查看计算样式和CSS优先级**。
5. **检查是否有视口裁剪或其他布局问题**。

### 如果元素的 `position` 仍然是默认值 `static`，则 `z-index` 不会生效。视口和裁剪原因

### 1. **堆叠上下文的定义**

一个堆叠上下文是 **由一个特定元素及其所有子元素构成的层叠区域**，这个区域内的元素的 `z-index` 值会互相比较以决定堆叠顺序。该堆叠上下文内的元素 **只与该上下文内的其他元素相比大小**，而不会和其他堆叠上下文中的元素进行比较。

### 2. **何时会创建堆叠上下文？**

并非所有元素都默认创建堆叠上下文，只有符合以下条件的元素才会创建堆叠上下文。一般来说，堆叠上下文由以下 CSS 属性触发：

#### 1. **根元素**（`<html>`）：

- 根元素 `<html>` 自带堆叠上下文，作为整个页面的最外层堆叠上下文。

#### 2. **定位元素**（`position`）：

- 当元素的 `position` 为 `relative`、`absolute`、`fixed` 或 `sticky`，并且该元素设置了 **`z-index`** 值时，会创建堆叠上下文。

在堆叠上下文内部，元素的显示顺序是通过它们的 `z-index` 值来确定的。若堆叠上下文的 `z-index` 值越大，整个上下文的堆叠顺序就越高。

- **父元素堆叠上下文的 `z-index` 影响子元素的显示顺序**，子元素的 `z-index` 不会跨越堆叠上下文的边界与其他上下文进行比较。
- **不同堆叠上下文之间的比较**，是由它们的 `z-index` 值在更高层的上下文中进行的。

**堆叠上下文** 是由具有特定 CSS 属性的元素创建的。它使得元素的堆叠顺序在某些层次中独立于其他元素。

**`z-index`** 决定了堆叠上下文内的元素的显示顺序，`z-index` 值大的元素会在小的元素上方。

不同堆叠上下文之间的元素相互独立，堆叠顺序是基于它们各自的 `z-index` 比较的。

## 手写css样式，超过两行显示省略号...

```css
div {
  display:-webkit-box;
  text-overflow:ellipsis;
  overflow:hidden;
  width:100px;
  -webkit-line-clamp: 2;
  -webkit-box-orient:vertical;
}
```



# 算法

## 删除有序链表的重复元素II



##  实现 getURLKey(url, key)



## url反转

.split('.').reverse().join('.')

### 堆的经典应用： Top K 问题（常见于腾讯、字节等面试中）

这种问题我们该怎么处理喃？我们以从数组中取前 K 大的数据为例，可以按以下步骤来：

- 从数组中取前 `K` 个数，构造一个小顶堆
- 从 `K+1` 位开始遍历数组，每一个数据都和小顶堆的堆顶元素进行比较，如果小于堆顶元素，则不做任何处理，继续遍历下一元素；如果大于堆顶元素，则将这个元素替换掉堆顶元素，然后再堆化成一个小顶堆。
- 遍历完成后，堆中的数据就是前 K 大的数据

遍历数组需要 O(N) 的时间复杂度，一次堆化需要 O(logK) 时间复杂度，所以利用堆求 Top K 问题的时间复杂度为 O(NlogK)。



作者：前端瓶子君
链接：https://juejin.cn/post/6844904179278823437
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

原地反转

##  原地反转

“原地反转”的思路简单，但是实现起来有一些细节需要处理。链表类的原地操作，大部分都是细节上容易出错，导致死循环或者报错。

准备当前节点 node，和 node 的前一个节点 preNode。整体的思路如下：一步一步往前移动，后指前，俩向后移

- 保留当前节点的下一个节点
- 将当前节点的 next 指向前一节点 preNode
- 更新 preNode 为当前节点，更新当前节点为第一步保留的下一节点
- 判断当前节点是否是最后节点，如果不是，回到第一步；如果是，进入最后一步
- 将当前节点的 next 指向前一节点 preNode

时间复杂度是 O(N)，空间复杂度是 O（1）。代码如下：

```js
// ac地址：https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/
// 原文地址：https://xxoo521.com/2020-01-12-reverse-link/
/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    if (!head) {
        return null;
    }

    let node = head;
    let preNode = null;
    while (node.next) {
        const nextNode = node.next;
        node.next = preNode;
        preNode = node;
        node = nextNode;
    }
    node.next = preNode;
    return node;
};
```

```

```





## js自定义实现一个类，支持链式调用，然后事件执行顺序和链式调用的顺序不一样，有优先级

```js
class chainC{
    constructor(){
        this.chain = [];
    }

    add(priority,fn){
        this.chain.push({priority,fn});
        return this
    }
    excute(){
        this.chain.sort((a,b)=>b.priority-a.priority);
        this.chain.forEach(item=>item.fn());
        this.chain = [];
        return this;
    }
}

const chain1 = new chainC();
chain1
.add(1,()=>console.log(1))
.add(2,()=>console.log(2))
.add(3,()=>console.log(3))
.excute()
.add(4,()=>console.log(4))
.add(5,()=>console.log(5))
.excute()
```

## this指向

```js
const a = 20;

let test = {
    a: 10,//是属性 得通过this获取
    init: () => {
        console.log(a);
        console.log(this.a);//
        function go() {
            this.a = 60;
            console.log(a);
        }
        go.prototype.a = 80;
        return go;
    }
};

const p = test.init();
p();
20
20
普通函数的 this：
普通函数的 this 取决于调用方式。
如果作为普通函数调用，this 指向全局对象（非严格模式）或 undefined（严格模式）。
全局变量与全局对象的属性：

通过 const 或 let 声明的全局变量不会挂载到全局对象上。它们存储在全局作用域的变量环境中，而不是挂载到全局对象上。因此，无法通过 window.a 或 global.a 访问到它们。
因此，this.a 是 undefined，而 a 是全局变量，值为 20。
通过 var 声明的全局变量：会成为全局对象的属性。

例如，var a = 20; 会将 a 挂载到全局对象上，可以通过 window.a 或 global.a 访问。
```



## new的理解

```js
function Person(name) {
    this.name = name;
    if (typeof this.getName !== 'function') {
        Person.prototype = {//关键之处在于这里的引用变了
            constructor: Person,
            getName: () => {
                console.log(this.name);
            }
        };
    }
}

const p1 = new Person('wwww');
console.log(p1);
p1.getName();

分析：
new的过程
    // 1.创建一个新对象
    const obj = {}
    // 2.新对象原型指向构造函数原型对象  原型链的建立发生在实例化时，即 new 操作的第一步。
    obj.__proto__ = Func.prototype
    // 3.将构建函数的this指向新对象
    let result = Func.apply(obj, args)
即创建、调用、指向
在动态绑定之前已经进行了指向，此时，p1 的原型链已经确定，后续对 Person.prototype 的修改
```

```js
class Person{
    constructor(exector){
        this.name=null;
        exector(this.setName('222'))
    }
    setName(name)this.name=name;
    getName()return this.name
}
function ex(fun) {
    fun()
}
const p1=new Person(ex)
p1.name
```

```js
class Person1 {
    constructor(exector) {
        this.name = null;
        exector((name) => this.setName(name)); // 使用箭头函数
    }
    setName(name) {
        this.name = name;
    }
}
箭头函数 (name) => this.setName(name) 定义在 Person1 的构造函数中。

它的外部作用域是 Person1 的构造函数，而构造函数的 this 指向当前实例（即 new Person1() 创建的对象）。

因此，箭头函数中的 this 也指向 Person1 实例。

当 exector 调用箭头函数时，this.setName(name) 中的 this 仍然是 Person1 实例，因此可以正确设置 name 属性。
```

###  **为什么箭头函数的外部作用域不是 `obj`？**

- **对象字面量 `{}` 不创建作用域**：
  - 在 JavaScript 中，对象字面量（例如 `const obj = { ... }`）不会创建新的作用域。
  - **箭头函数的作用域是由它的定义位置决定的**，而不是它所在的对象的上下文。
- **箭头函数的作用域链**：
  - 箭头函数的作用域链是静态的，由它的定义位置决定。
  - 在这里，箭头函数 `method` 定义在全局作用域中，因此它的 `this` 指向全局对象。
  - `在 JavaScript 中，函数的调用方式取决于调用时的语法，而不是定义时的语法。

# React

## React应用能不能被搜索引擎搜索到

### 服务端渲染（SSR）

原理：服务端渲染是在服务器端将 React 组件渲染为完整的 HTML 页面，然后将这个 HTML 页面发送给客户端。这样，搜索引擎爬虫在访问页面时，能够看到完整的内容，就像访问传统的多页应用一样。

### 预渲染

原理：预渲染是在构建阶段预先渲染 React 应用的一些关键页面，并生成静态的 HTML 文件。这些 HTML 文件可以被部署到服务器上，供搜索引擎爬虫抓取。



## 微前端实现原理？



## fiber和深度遍历的区别

有回溯，没有兄弟节点的话，返回父节点

横向走，有兄弟节点的话，转向兄弟节点

## fiber的diff算法比较的三层级

**1. **节点级别（Node Level）

**类型**：比较两个节点的类型是否相同（如两个 `div` 元素，或两个 `MyComponent` 组件）。如果类型不匹配，React 会选择删除旧节点并创建一个新的节点。

**Key**：在同一层级下，React 使用 `key` 属性来识别节点的唯一性，`key` 是用来优化更新操作的。如果 `key` 不同，React 会认为这是两个不同的元素。

**Props**：如果节点类型相同，React 会进一步比较 `props` 是否发生变化。如果 `props` 有变化，React 会更新对应的 DOM 或组件。

### 2. **子树级别（Subtree Level）**

这一级别的比较主要发生在 **组件树的子节点之间**，即当父组件的结构发生变化时，React 需要更新它的子组件。React 会递归地比较父组件下的每个子节点，直到找到具体的差异。



## useState的原理



## 什么导致了useState有时的表现是同步，有时是异步

### 1. **批处理更新**

React 会将多个状态更新合并为一次重新渲染，以提高性能。这意味着在事件处理函数或生命周期方法中，多个 `useState` 调用会被合并，表现为异步更新。

```
function MyComponent() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setCount(count + 1);
    setCount(count + 1); // 这两个更新会被合并，最终 count 只增加 1
  };

  return <button onClick={handleClick}>Count: {count}</button>;
}
```



### 2. **同步更新的场景**

在某些情况下，`useState` 的更新会立即生效，表现为同步行为。例如：

- **在 `setTimeout` 或 `Promise` 回调中**：React 不会对这些回调中的状态更新进行批处理，因此更新会立即执行。

- **`setTimeout` 和 `setInterval`**：在这类异步操作的回调中，React 不会批量处理状态更新。因为这些回调并不直接由 React 控制，而是由浏览器或 JavaScript 事件循环触发的。React 不会自动批处理在这些回调中的状态更新。

  **`Promise` 回调**：`Promise` 回调是异步的，但由于它们是由 JavaScript 事件循环触发的，React 也不会在这些回调中进行批处理，因此状态更新会立即生效。

- **使用函数式更新**：通过传递函数给 `setCount`，可以确保基于最新状态进行更新。

```
function MyComponent() {
  const [count, setCount] = useState(0);

  const handleClick = () => {
    setTimeout(() => {
      setCount(count + 1); // 同步更新
    }, 1000);
  };

  return <button onClick={handleClick}>Count: {count}</button>;
}
```



## React组件之间常用的通信方式

### 1. **父子组件通信**

父组件通过 **props** 向子组件传递数据，子组件通过调用父组件传递的回调函数与父组件通信。

```JS
function Parent() {
  const handleDataFromChild = (data) => {
    console.log("Data from child:", data);
  };

  return <Child onSendData={handleDataFromChild} />;
}

function Child({ onSendData }) {
  const sendData = () => {
    onSendData("Hello from Child");
  };

  return <button onClick={sendData}>Send Data</button>;
}
```

### 2. **兄弟组件通信**

```JS
function Parent() {
  const [sharedData, setSharedData] = useState("");

  return (
    <>
      <ChildA onSendData={setSharedData} />
      <ChildB data={sharedData} />
    </>
  );
}

function ChildA({ onSendData }) {
  const sendData = () => {
    onSendData("Data from ChildA");
  };

  return <button onClick={sendData}>Send Data</button>;
}

function ChildB({ data }) {
  return <div>Received: {data}</div>;
}
```

### 3. **跨层级组件通信**

React 的 `Context` 提供了一种跨层级传递数据的方式，无需手动逐层传递 props。

对于复杂的应用，可以使用全局状态管理工具（如 Redux、Zustand、Recoil 等）来管理共享状态。

### 4. **事件总线（Event Bus）**

### 5. **Ref 和 ForwardRef**

通过 `ref` 直接访问子组件的实例或 DOM 元素，适用于需要直接操作子组件的场景。

父组件调用子组件的方法：可以用什么 Hook

在 React 函数组件中，父组件可以通过 **`useRef`** 和 **`forwardRef`** 来调用子组件的方法。

1. **`useRef`**：通过 `useRef`，父组件可以创建对子组件的引用，从而调用子组件的方法。
2. **`forwardRef`**：由于函数组件默认没有实例，因此使用 `forwardRef` 可以让父组件访问子组件的方法。

#### 示例：父组件调用子组件的方法

```js
import React, { useRef } from 'react';

// 子组件
const Child = React.forwardRef((props, ref) => {
  const handleClick = () => {
    alert('Child component method called!');
  };

  // 通过 ref 暴露方法
  React.useImperativeHandle(ref, () => ({
    handleClick,
  }));

  return <div>Child Component</div>;
});

// 父组件
const Parent = () => {
  const childRef = useRef();

  const callChildMethod = () => {
    if (childRef.current) {
      childRef.current.handleClick();  // 调用子组件的方法
    }
  };

  return (
    <div>
      <Child ref={childRef} />
      <button onClick={callChildMethod}>Call Child Method</button>
    </div>
  );
};

export default Parent;

```



### 6. **自定义 Hooks**

```js
function useSharedState(initialValue) {
  const [value, setValue] = useState(initialValue);
  return [value, setValue];
}

function ComponentA() {
  const [value, setValue] = useSharedState("");

  return (
    <input
      value={value}
      onChange={(e) => setValue(e.target.value)}
    />
  );
}

function ComponentB() {
  const [value] = useSharedState("");
  return <div>{value}</div>;
}
```

## react的context刷新怎么解决，useEffect对应那些生命周期，useEffect(()→{}，[])能获取dom吗?如果里面使用useState(false)

**React Context 刷新问题**：为了避免过多的渲染，可以使用 `useMemo` 来优化 `Context` 的值，保持不可变性，并尽可能拆分 `Context`。

**`useEffect` 生命周期对应**：`useEffect` 用于处理副作用，它与类组件的 `componentDidMount`、`componentDidUpdate` 和 `componentWillUnmount` 类似。

**`useEffect` 和 DOM 获取**：`useEffect` 可以在组件挂载后获取到 DOM 元素，因为它会在渲染后执行。

**`useState(false)` 在 `useEffect` 中的作用**：`useState` 的初始值是 `false`，并可以通过 `useEffect` 更新状态，这样会触发组件重新渲染。

## 既然state已经是响应式的对象了，为什么还要使用useMemo 来优化 Context 的值

虽然 React 的 `state` 是响应式的，但当我们将 `state` 传递到 `Context` 中时，React **默认没有对传递的 `Context` 值进行优化**，这可能导致不必要的重新渲染。具体来说，React 进行渲染的决定是基于 `Context` 的值是否发生变化来判断的，而这通常是通过**引用比较**来判断的。

每次 `MyProvider` 渲染时，`value` 对象的引用都会发生变化，即使 `state` 没有变化，React 也会认为 `Context` 的值发生了变化，并且会重新渲染所有消费者组件。

## **`useMemo` 的作用**

为了避免每次渲染时都创建新的 `Context` 值，可以使用 `useMemo` 来**缓存**这个值，只有当 `state` 改变时才重新计算 `value`。这样可以保证 `Context` 的值引用保持稳定，避免不必要的重新渲染。



## HOC（高阶组件）和 Hooks 各自的优缺点

#### **HOC（高阶组件）**：

HOC 是一个函数，它接受一个组件并返回一个新组件，通常用于复用组件逻辑。

##### **优点**：

- **复用逻辑**：能够将组件的逻辑进行抽象并复用。
- **装饰现有组件**：可以通过增强原始组件的功能，比如注入额外的 props 或实现条件渲染。

##### **缺点**：

- **难以调试**：由于 HOC 会包装组件，这使得堆栈跟踪和调试变得更加复杂。
- **Props 冲突**：传递给组件的 props 可能会被 HOC 修改，导致出现 props 冲突。
- **嵌套问题**：多个 HOC 嵌套会导致代码层次过深，难以维护。

#### **Hooks**：

Hooks 是 React 16.8 引入的功能，允许在函数组件中使用状态和副作用。

##### **优点**：

- **简洁和易读**：函数组件代码更简洁，无需生命周期方法和 `this` 绑定，易于理解。
- **组件复用**：通过自定义 Hooks 可以复用逻辑，而不需要修改组件的结构。
- **无嵌套问题**：不像 HOC 那样会有嵌套的问题，逻辑复用更加清晰。

##### **缺点**：

- **复杂的状态管理**：对于复杂的状态逻辑（如多个 `useState` 或 `useReducer`），代码可能变得复杂。
- **React 升级时的兼容性问题**：虽然 `useEffect` 和其他 Hooks 可以替代许多生命周期方法，但需要理解 React 的更新机制，避免引发不必要的重新渲染。

## React 的 Class 组件和函数组件的区别

1. **语法**：

   - **Class 组件**：使用 ES6 的 `class` 语法，继承 `React.Component`，并通过 `render` 方法返回 JSX。
   - **函数组件**：使用普通的 JavaScript 函数，直接返回 JSX。

2. **状态管理**：

   - **Class 组件**：通过 `this.state` 和 `this.setState` 来管理状态。

   ```js
   class MyComponent extends React.Component {
     constructor(props) {
       super(props);
       this.state = { name: 'John' };
     }
   
     render() {
       return <div>{this.state.name}</div>;
     }
   }
   
   ```

   

   - **函数组件**：在 React 16.8 之前，函数组件是无状态的。自 React 16.8 引入 Hooks 后，可以使用 `useState` 来管理状态。

3. **生命周期**：

   - **Class 组件**：可以使用生命周期方法，如 `componentDidMount`、`componentDidUpdate`、`componentWillUnmount` 等。
   - **函数组件**：使用 `useEffect` Hook 来模拟生命周期方法。

4. **代码简洁性**：

   - **函数组件**：通常代码更简洁，易于理解和维护。
   - **Class 组件**：代码相对复杂，尤其是在处理生命周期方法和状态管理时。

5. **性能**：

   - **函数组件**：通常性能更好，因为函数组件没有实例化的开销。
   - **Class 组件**：由于需要实例化，可能会有轻微的性能开销。

## react16.8前后有什么不同 做迁移的时候有哪些需要注意的地方

React 16.8 之前和之后最大的不同在于 **React Hooks** 的引入。React 16.8 版本之前，React 主要使用 **类组件（Class Components）** 来管理状态和生命周期，而在 16.8 之后，引入了 **Hooks**，使得函数组件（Function Components）可以管理状态和副作用，从而减少类组件的使用。

### **1. 替换类组件为函数组件**

- **可以先从无状态的类组件开始迁移**，因为它们的逻辑较简单。
- 对于复杂的类组件，优先用 `useState` 和 `useEffect` 替换 `this.state` 和生命周期方法。

### 2.生命周期方法的映射

| **类组件生命周期**     | **Hooks 替代方案**                           |
| ---------------------- | -------------------------------------------- |
| `componentDidMount`    | `useEffect(() => {...}, [])`                 |
| `componentDidUpdate`   | `useEffect(() => {...}, [state])`            |
| `componentWillUnmount` | useEffect(() => { return () => {...}; }, []) |





# VUE

## Vue 的双向绑定机制的实现原理



在 Vue3 中的升级



## Vue 在渲染列表时候 key 的作用



- ### vue中生命周期有哪些，都干了什么事情

  创建、挂载、更新、销毁

  创建，实例初始化------》完成数据的绑定

  挂载，给VUE实例对象添加$EL对象，数据渲染

  更新，数据变化自动执行，对应组件重新渲染

- ### 销毁的生命周期干了什么

  销毁，组件、数据绑定、监听、子实例

- #### Vue中的data为什么是以一个函数的格式存在

  数据劫持

- #### keep-alive用来做什么的，说下原理

  `<KeepAlive>` 包裹动态组件时，会缓存不活跃的组件实例，而不是销毁它们(v-if` 和 `v-show会导致销毁重建)

  在mounted这个钩子中对include和exclude参数进行监听，然后实时地更新（删除）this.cache对象数据。

  就是挂载时把虚拟dom缓存到内存中，以后再渲染时就直接拿内存中的虚拟dom

- #### 组件生命周期打印顺序

  1. beforeCreate
  2. created
  3. beforeMount
  4. mounted
  5. beforeUpdate
  6. updated
  7. activated  
  8. deactivated
  9. beforeDestroy
  10. destroyed
  11. errorCaptured

- #### 父子组件生命周期打印顺序

  ```text
  父beforeCreate->父created->父beforeMount->子beforeCreate->子created->子beforeMount->子mounted->父mounted->父beforeDestroy->子beforeDestroy->子destroyed->父destroyed
  ```

- #### 哪个生命周期可以最先获取$el

  挂载前 data el都初始化好了，但el里没数据

- #### 哪个生命周期可以获取DOM节点

  挂载后

- 组件通信有哪些方法

  

  ## NextTick 用途

  用法：**点击按钮显示原本以 v-show = false 隐藏起来的输入框，并获取焦点。**

  ```js
  showsou(){
    this.showit = true //修改 v-show
    document.getElementById("keywords").focus()  
      //在第一个 tick 里，获取不到输入框，自然也获取不到焦点
  }
  
  ```

  原理：

  timerFunc函数是nextTick方法的关键。它会根据当前浏览器环境的支持情况，选择不同的异步执行方式。如果浏览器支持Promise对象，则使用Promise.resolve().then(flushCallbacks)来添加microtask任务；如果浏览器不支持Promise对象但支持MutationObserver，则使用MutationObserver，在文本节点变化时执行回调函数；否则，使用setTimeout来异步地执行回调函数。

  

  作者：Cosolar
  链接：https://juejin.cn/post/7224840969790193722
  来源：稀土掘金
  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

- 路由的导航守卫有哪些，具体分别哪几类

  **全局守卫**

  vue-router全局有三个守卫：

  1. router.beforeEach 全局前置守卫 进入路由之前   **关闭播放器 **   **判断是否需要登录**
  2. router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用
  3. router.afterEach 全局后置钩子 进入路由之后

  **路由独享守卫**

  **路由组件内的守卫**：

  ### 完整的路由导航解析流程(不包括其他生命周期)：

  1. 触发进入其他路由。
  2. 调用要离开路由的组件守卫`beforeRouteLeave`
  3. 调用局前置守卫：`beforeEach`
  4. 在重用的组件里调用 `beforeRouteUpdate`
  5. 调用路由独享守卫 `beforeEnter`。
  6. 解析异步路由组件。
  7. 在将要进入的路由组件中调用`beforeRouteEnter`
  8. 调用全局解析守卫 `beforeResolve`
  9. 导航被确认。
  10. 调用全局后置钩子的 `afterEach` 钩子。
  11. 触发DOM更新(`mounted`)。
  12. 执行`beforeRouteEnter` 守卫中传给 next 的回调函数

  

  作者：OBKoro1
  链接：https://juejin.cn/post/6844903641866829838
  来源：稀土掘金
  著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

- router和route的区别，分别有哪些属性和方法

$router是VueRouter的一个对象，通过Vue.use(VueRouter)和Vue构造函数得到一个router的实例对象，这个对象中是一个全局的对象，他包含了所有的路由，包含了许多关键的对象和属性。

`$route`是一个跳转的路由对象，每一个路由都会有一个$route对象，是一个局部的对象，可以获取对应的name，path，params，query等

- 路由传参



- 说下Vue函数式组件

  

- Vue双向绑定原理

- Object.defineProperty 做响应式有什么缺点

- MVC、MVVM、MVP这三种有什么区别

- computed和watch的区别

缓存、return

- 过滤器的作用，如何实现一个过滤器
- 常见的事件修饰符，以及作用
- v-if v-show 区别
- v-model 如何实现的，原理
- v-model 中Vue2和Vue3的区别
- Vue数组的方法有哪些，如何实现视图更新的
- 单页应用和多页应用的区别
- Vue初始页面闪动问题
- Vue视图发生改变的时候，视图会立马同步渲染吗

> `Vue` 在修改数据后，视图不会立刻更新，而是等**同一事件循环**中的所有数据变化完成之后，再统一进行视图更新。
>
> `Vue` 中 `data` 的数据变化是**同步**的，更新完就能拿到；但是 `dom` 的更新是**异步**的，需要用`nextTick` 去即时获取
>
> **说白了就是因为 `Vue` 是异步执行 `DOM` 更新的，想立即操作更新后的 `DOM` 就需要使用 `$nextTick`**
>
> **链接：https://juejin.cn/post/6970877981778509838**

- template和jsx有什么区别
- Vue中子组件可以直接改变父组件的数据吗
- Vue内置指令
- 组件中的name属性有什么作用
- Vue中使用了哪些设计模式
- Vue.$set原理
- v-model的修饰符有哪些
- 组件和插件有哪些区别
- Vue如何解除数据绑定

## 什么是状态？为什么要管理状态？

https://juejin.cn/post/7092973028912414727?searchId=20230801165457220910D6C1CBCD02CC2C

1. 组件是如何感知到状态的变化的？

   通过 props，把当前组件的 state 作为 props 传入其他组件就行了，这样就能联动变化。

2. state和props的区别

3. 受控组件和非受控组件的区别，各自的使用场景

4. 怎么做优化？

## Vue 3 中的 `ref` 和 `reactive` 的区别

`ref` 通常用于包装基础类型（如 `String`, `Number`, `Boolean` 等），因为它们本身不是响应式的。 当你使用 `ref` 包裹一个值时，Vue 会返回一个包含 `.value` 属性的对象，你需要通过 `.value` 来访问和修改这个值。

`reactive` 用于创建一个 **深度响应式** 的对象或数组。即通过 `reactive` 创建的对象的所有嵌套属性都会是响应式的，适用于管理复杂的对象结构。

## webpack中loader作用



## webpack中hash 、 chunk hash 、 content hash区别 

- **hash** ：任何一个文件改动，整个项目的构建 hash 值都会改变；
- **chunkhash**：文件的改动只会影响其所在 chunk 的 hash 值；
- **contenthash**：每个文件都有单独的 hash 值，文件的改动只会影响自身的 hash 值；



## webpack中热更新原理

**是什么**；热更新时只会局部刷新页面上发生了变化的模块，同时可以保留当前页面的状态，比如复选框的选中状态等

**怎么实现**：`webpack-dev-server`与浏览器之间维护了一个`websocket`，当本地资源发生变化时，`webpack-dev-server`会向浏览器推送更新，并带上构建时的`hash`，让客户端与上一次资源进行对比。客户端对比出差异后会向`webpack-dev-server`发起 Ajax 请求来获取更改内容(文件列表、hash)，这样客户端就可以再借助这些信息继续向`webpack-dev-server`发起 jsonp 请求获取该`chunk`的增量更新。



作者：庸人自扰的庸人
链接：https://juejin.cn/post/7196630860811075642
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。



## webpack中externl作用（**√**）

`externals` 配置选项提供了「**从输出的 bundle 中排除依赖**」的方法。此功能通常对 **library 开发人员**来说是最有用的，然而也会有各种各样的，例如，从 CDN 引入 jQuery，而不是把它打包：应用程序用到它。

我们可以用这样的方法来剥离不需要改动的一些依赖，大大节省打包构建的时间。



## SSR

**服务端渲染（ssr）**，是指由服务器端完成页面的**HTML** 结构拼接，并且直接将拼接好的**HTML**发送到浏览器，然后为其绑定状态与事件，成为完全可交互页面的处理技术。

更好的SEO\更利于首屏渲染

流程图大致意思是：

1. 左边是源代码，app.js被server/client共用，在生产环境下是不用执行的。
2. 右边是编译后的文件，两份打包后的文件。
3. 一份运行在服务器端，在服务器上有一个打包的渲染函数负责渲染输出浏览器所需要的html页面
4. 一份运行在浏览器端，负责跟这份html页面交互，判断当前服务器返回的数据是否是当前URL对应页面的数据。如果不是的话它会请求一次服务器再渲染，如果是的话它就按照正常vue架构接管页面

注意：**服务端只是生成前期首屏页面所需的 html ，后期的交互和数据处理还是需要能支持浏览器脚本的 Client Bundle 来完成。**



作者：Excellentxs
链接：https://juejin.cn/post/7000973688732385293
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

![786a415a-5fee-11e6-9c11-45a2cfdf085c.png](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/2e933765c2324b62b073009ea4d6be48~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)



## router 两种路由模式



**什么是路由？**

**路由就是用来跟后端服务器进行交互的一种方式**，通过`不同的路径`，来`请求不同的资源`，请求不同的页面是路由的其中一种功能

**什么是前端路由？**

简单的说，就是在保证只有一个 HTML 页面，且与用户交互时不刷新和跳转页面的同时，为 SPA 中的每个视图展示形式匹配一个特殊的 url。在刷新、前进、后退和SEO时均通过这个特殊的 url 来实现。

### hash 模式

- 原理
   基于浏览器的hashchange事件，地址变化时，通过window.location.hash 获取地址上的hash值；并通过构造Router类，配置routes对象设置hash值与对应的组件内容。
- 优点

1. hash值会出现在URL中, 但是不会被包含在Http请求中, 因此hash值改变不会重新加载页面
2. hash改变会触发hashchange事件, 能控制浏览器的前进后退
3. 兼容性好

不太美观，# 后面传输的数据复杂的话会出现问题

### history 模式

基于HTML5新增的pushState()和replaceState()两个api，以及浏览器的popstate事件，地址变化时，通过window.location.pathname找到对应的组件。并通过构造Router类，配置routes对象设置pathname值与对应的组件内容。

没有#，更加美观

pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL

pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中

pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中

pushState() 可额外设置 title 属性供后续使用

#### 在 history 路由中，我们一定会使用`window.history`中的方法，常见的操作有：

- back()：后退到上一个路由；
- forward()：前进到下一个路由，如果有的话；
- go(number)：进入到任意一个路由，正数为前进，负数为后退；
- pushState(obj, title, url)：前进到指定的 URL，不刷新页面；
- replaceState(obj, title, url)：用 url 替换当前的路由，不刷新页面；

#### 应用的场景

### pushState 和 replaceState 两个方法跟 location.href 和 location.replace 两个方法有什么区别呢？应用的场景有哪些呢？

1. location.href 和 location.replace 切换时要向服务器发送请求，而 pushState 和 replace 仅修改 url，除非主动发起请求；
2. 仅切换 url 而不发送请求的特性，可以在前端渲染中使用，例如首页是服务端渲染，二级页面采用前端渲染；
3. 可以添加路由切换的动画；
4. 在浏览器中使用类似抖音的这种场景时，用户滑动切换视频时，可以静默修改对应的 URL，当用户刷新页面时，还能停留在当前视频。

### 如何选择hash和history

总的来说，Hash 模式适合开发纯前端应用，不需要服务器的支持，但是 URL 比较丑陋。History 模式适合开发需要 SEO 支持的应用，但是需要服务器的支持，并且需要进行 URL 重写以去除 URL 中的 # 号。

如果你不需要考虑 SEO 问题，或者你的服务器配置不允许 URL 重写，那么可以选择使用 hash 模式；

如果你需要考虑 SEO 问题，或者你的服务器支持 URL 重写，那么可以选择使用 history 模式。



https://www.cnblogs.com/miangao/p/17092662.html

作者：前端_林菜菜
链接：https://juejin.cn/post/6867875626611654663
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

## 我监听LocalStorage时候尝试的方法。。。

- watch：vue只能监听data属性下的数据变化，根本监听不到`localStorage`，`sessionStorage`等全局对象的变化。

- *// window全局监听localStorage的setItem事件,从而及时监听* window.addEventListener('setItemEvent', function (e) {  console.log(e.oldValue, e.newValue, e.key )  ... })

  上述代码很规范，看不出任何问题，但是在火狐浏览器上遇到了问题，即**监听失效了！**

  以上不难看出，其实谷歌浏览器重写setItem的本质就是给Storage**增加实例属性**，当我们在调用setItem时会优先搜索到实例中的setItem属性，而其原型属性setItem没有发生变化。
  但是火狐浏览器不这么认为，他会筛掉setItem，不把它保存在实例属性中，但是会把它做为本地值存储起来。

- ```
  强：一些浏览器原生的方法，我们不要去重写，而是以中间件的方式修改。
  ```

  所以强师傅用了**Proxy代理 和 Object.defineProperty**来做相应式监听，这也是VUE3.0极力推荐的方式。

  使用watch方法监听内存，当name发生变化时，将变化值与当前页面的名称做一个比较

  

### 

# 微前端

## 1.谈谈qiankun的实现

究竟什么是Shadow DOM？https://zhuanlan.zhihu.com/p/559759502

## shadow dom 是什么？

顾名思义，shadow dom直译的话就是影子dom，但我更愿把它理解为[DOM](https://zhida.zhihu.com/search?content_id=212523801&content_type=Article&match_order=1&q=DOM&zhida_source=entity)中的DOM。因为他能够为Web组件中的 DOM和 CSS提供了封装，实际上是在浏览器渲染文档的时候会给指定的DOM结构插入编写好的DOM元素，但是插入的[Shadow DOM](https://zhida.zhihu.com/search?content_id=212523801&content_type=Article&match_order=1&q=Shadow+DOM&zhida_source=entity) 会与主文档的DOM保持分离，也就是说Shadow DOM不存在于主DOM树上。

并且**Shadow DOM封装出来的DOM元素是独立的，外部的配置不会影响到内部，内部的配置也不会影响外部。**

https://juejin.cn/post/7338230967390224435



## 2.为什么用qiankun(讲了iframe)

### iframe

HTML 内联框架元素 `<iframe>` 表示嵌套的浏览上下文（Browsing context），能有效地将另一个 HTML 页面嵌入到当前页面中。

但是，iframe 也有很多**送命**问题：

- dom 割裂严重，视窗大小不同步：例如我们在 iframe 内的弹窗想要居中展示。
- 子应用间通信问题：只能通过 `postMessage` 传递序列化的消息。
- 额外的性能开销：加载速度、构建 iframe 环境导致白屏时间太长。
- 路由状态丢失：刷新一下，iframe 的 url 状态就丢失了。

### 基于iframe的无界https://cloud.tencent.com/developer/article/1919034

1. **利用** **iframe** **的隔离性，把** **JS** **代码放到 iframe 里执行（通过 Proxy）。**
2. **利用** **Shadow** ******DOM** **的隔离性，把子应用的 DOM 写到 ShadowRoot 里，实现样式隔离。**

假设我们有 A 应用，想要加载 B 应用：

在应用 A 中构造一个`shadow`和`iframe`，然后将应用 B 的`html`写入`shadow`中，`js`运行在`iframe`中，**注意**`**iframe**`**的**`**url**`，`iframe`保持和主应用同域但是保留子应用的路径信息，这样子应用的`js`可以运行在`iframe`的`location`和`history`中保持路由正确。

在`iframe`中拦截`document`对象，统一将`dom`指向`shadowRoot`，此时比如新建元素、弹窗或者冒泡组件就可以正常约束在`shadowRoot`内部。

我们可以发现：

- ✅ 首次白屏的问题，`wujie`实例可以提前实例化，包括`shadowRoot`、`iframe`的创建、`js`的执行，这样极大的加快子应用第一次打开的时间
- ✅ 切换白屏的问题，一旦`wujie`实例可以缓存下来，子应用的切换成本变的极低，如果采用保活模式，那么相当于`shadowRoot`的插拔

### single-spa

**主应用通过路由匹配实现对子应用生命周期的管理**

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/93cb101e6de344c49f64361dc574c3d7~tplv-k3u1fbpfcp-jj-mark:3024:0:0:0:q75.awebp#?w=1522&h=1288&s=198227&e=png&b=fffffe)

- **主应用如何导入子应用？** 这个需要用户自行定义，官方推荐的是 SystemJS + import maps。
- importmap 的功能就是告诉 'vue' 这个玩意要从 "[https://cdn.jsdelivr.net/npm/vue@2.6.12/dist/vue.esm.browser.js](https://link.zhihu.com/?target=https%3A//cdn.jsdelivr.net/npm/vue%402.6.12/dist/vue.esm.browser.js)" 这里来的。不过，importmap 现在只有 Chrome 是支持的。
- SystemJS 就将这一块补齐了。当然，除了 importmap，它还有很多的功能，比如获取当前加载的所有模块、当前模块的 URL、可以 import html, import css，import wasm。
- 当路由触发，Single-spa 会检查当前是否需要加载和渲染某个子应用。子应用的 `mount` 函数会被调用，子应用的内容会被挂载到主应用的 DOM 中。这通常通过将子应用的内容渲染到某个指定的 DOM 容器中实现。主应用中的容器通常是一个空的 `<div>`，Single-spa 会将子应用的 UI 渲染到该容器。

### 基于 single-spa 的 qiankun、 Garfish、icestark 等

这里**总结**一下single-spa是如何通过以上方法加载子应用的：

在主应用中注册子应用的配置信息，主应用运行时根据配置信息去请求子应用的manifest.json配置文件，这个文件中是子应用打包出的入口js和js文件的依赖关系，主应用通过动态的构造script标签去加载这些js文件，这里就完成了其注册过程。

这样在主应用检测路由命中子应用的规则之后就会触发其渲染函数，把子应用挂载到相应的dom下。

1. **single-spa**。 我就不再多介绍了，只提一嘴，这就是 qiankun 和 single-spa 的 API 为啥那么相似的原因。
2. **import-html-entry**。简单地说，就是一个加载并处理 HTML、JS、CSS 的第三方库——qiankun 通过这个库来加载子应用的资源从而做进一步处理。那都要处理啥呢？请看第三条。
3. **隔离/通信等机制**。这一块也就是我们需要重点关注的 qiankun 的**精髓**了。

## 3.qiankun中样式隔离和js隔离如何实现 

### **📖📖 核心技术点之 JS 沙箱**

在 `activate` 的时候遍历 Window上的变量，存为 **snapshotOriginal**。

在 `deactivate` 的时候再次遍历 Window 上的变量，分别和 **snapshotOriginal** 对比，将不同的存到 **snapshotMutated** 里，将 Window 恢复回到 **snapshotOriginal**。

当应用再次切换的时候，就可以把 **snapshotMutated** 的变量恢复回 Window 上，实现一次沙箱的切换。

```js
const varBox = {};
const fakeWindow = new Proxy(window, {
    get(target, key) {
        return varBox[key] || window[key]
    },
    set(target, key, value) {
        varBox[key] = value;
        return true;
    }
})
// 'with' 语句将某个对象添加到作用域链的顶部，如果在函数体 statement 中有某个未使用
// 命名空间的变量，跟作用域链中的某个属性同名，则这个变量将指向这个属性值
const fn = new Function('window', `
    with(window) {
        window.localstorage.setItem('1',123);
    }`
);
fn(fakeWindow);

```

https://cloud.tencent.com/developer/article/1946575

### **📖📖 核心技术点之样式隔离**

- 在切换子应用时，通过删除子应用各自的 css 样式表来隔离。严格样式隔离，核心是Shadow DOM。它可以让一个dom拥有自己的“影子”DOM树，这个DOM树不能在主文档中被任意访问，可以拥有局部样式规则，**天然实现了样式隔离**，

## 4.qiankun子应用中动态注入的css样式要如何处理

css隔离主要分为两种，一种是父子之间的隔离，另一种是子子之间的隔离。子应用之间的隔离，qiankun中并没有特别的提出，本质上就是在子应用加载时把其相应的样式加载进来，在卸载时进行移除即可。而父子之间的隔离在qiankun种有两种实现方法。

第一种是严格样式隔离，核心是Shadow DOM。它可以让一个dom拥有自己的“影子”DOM树，这个DOM树不能在主文档中被任意访问，可以拥有局部样式规则，**天然实现了样式隔离**，如上图所示，被代理的dom节点称为shadow host，shadow tree中的根节点称为shadow root。

第二种父子样式隔离是实验性样式隔离 ，即通过运行时**修改CSS选择器**来实现子应用间的样式隔离。

下面也是一个模拟污染的demo，可以看到主应用和子应用有重名的选择器，子应用在后面，所以父样式被覆盖，造成了污染。这里首先获取到子应用，然后通过正则匹配其中的所有<style>标签，给每一个标签加上前缀，从而缩小其样式应用的范围。

`qiankun` 会在加载子应用时，为每个子应用创建一个沙箱环境，并在子应用卸载时清理该子应用的所有资源，包括动态注入的 CSS 样式。

**原理：**

- 在加载子应用时，`qiankun` 会自动插入 `<style>` 标签或者 `<link>` 标签来加载子应用的 CSS。
- 当子应用被卸载时，`qiankun` 会自动清除这些动态注入的样式，确保主应用的样式不受影响。

**如何解析css**？

1. 正则匹配<style><link>标签。
2. 内联css （<style>标签）的内容会直接记录到一个对象中。
3. 外链css （ <link>标签）则会使用fetch请到到内容（字符串），然后记录到这个对象中，执行时内容放到<style>标签，然后插入到页面，子项目卸载移除这些<style>标签，这样会把外链的css变成内联css，切换子系统，不用重复请求，直接应用css样式，让子项目加载得更快。

# 设计模式

## 1. **单例模式 (Singleton Pattern)**

- **用途**：确保一个类只有一个实例，并提供全局访问点。
- **应用场景**：
  - 全局状态管理（如Redux中的Store）。
  - 弹窗组件（确保同一时间只存在一个弹窗）。

```
class Singleton {
  constructor() {
    if (!Singleton.instance) {
      Singleton.instance = this;
    }
    return Singleton.instance;
  }
}

const instance1 = new Singleton();
const instance2 = new Singleton();
console.log(instance1 === instance2); // true
```

## 2. **观察者模式 (Observer Pattern)**

- **用途**：定义对象间的一对多依赖关系，当一个对象状态改变时，所有依赖它的对象都会收到通知。
- **应用场景**：
  - 事件监听（如DOM事件）。
  - 状态管理库（如Redux、Vuex）。

```
class Subject {
  constructor() {
    this.observers = [];
  }
  subscribe(observer) {
    this.observers.push(observer);
  }
  unsubscribe(observer) {
    this.observers = this.observers.filter(obs => obs !== observer);
  }
  notify(data) {
    this.observers.forEach(observer => observer.update(data));
  }
}

class Observer {
  update(data) {
    console.log("Received data:", data);
  }
}

const subject = new Subject();
const observer = new Observer();
subject.subscribe(observer);
subject.notify("Hello World!"); // Observer logs: "Received data: Hello World!"
```

### IntersectionObserver

IntersectionObserver 是一种原生JavaScript API，用于异步监测元素与其祖先元素（或视口）交叉状态的变化。

也就是说，帮助我们监听某个元素进入或离开视口时的操作

应用场景：懒加载图片、触发动画效果、无限滚动等

优势：与传统的滚动监听方法相比，不需要不断监听滚动事件，而是由浏览器在合适的时候自动触发，减少了性能开销也更高效。

IntersectionObserver通过一个观察器来监听元素的交叉状态变化。观察器会接收两个主要的参数：

> 回调函数（callback）：当监听的元素的交叉状态发生变化时，会调用此回调函数。
> 配置对象（options）：配置观察器行为的选项，包括根元素、阈值

```
const observer = new IntersectionObserver((entries, observer) => {
   entries.forEach(entry => {
          if (entry.isIntersecting) {
              console.log('元素进入视口', 111);
              console.log(entry.target.id);
              entry.target.style.backgroundColor = 'lightgreen';
          } else {
              console.log('元素离开视口', 222);
              entry.target.style.backgroundColor = 'lightblue';
          }
      });
  }, {
      root: null, // 观察视口，null 代表整个浏览器窗口
      rootMargin: '0px', // 视口边缘的额外间距
      threshold: 0.5 // 触发回调的交叉比例（0到1之间）
  });
  const box = document.getElementById('box'); // 获取要观察的元素
  observer.observe(box); // 开始观察元素

```

(1) 创建一个**IntersectionObserver** 实例,并提供一个回调函数来处理元素交叉状态变化。

 (2) 配置root等配置 

(3) 使用**observe**() 方法将目标元素添加到观察器中，这里我们是为了观察目标元素，    开始监控 target-element 元素    当其与视口的交叉状态发生变化时，我们就可以调用回调函数。

## 3. **发布-订阅模式 (Pub-Sub Pattern)**

- **用途**：类似于观察者模式，但通过消息中心解耦发布者和订阅者。
- **应用场景**：
  - 跨组件通信（如Vue的EventBus）。
  - 消息队列系统。

```
class EventBus {
  constructor() {
    this.events = {};
  }
  on(event, callback) {
    if (!this.events[event]) {
      this.events[event] = [];
    }
    this.events[event].push(callback);
  }
  emit(event, data) {
    if (this.events[event]) {
      this.events[event].forEach(callback => callback(data));
    }
  }
}

const eventBus = new EventBus();
eventBus.on("message", (data) => console.log("Received:", data));
eventBus.emit("message", "Hello World!"); // Logs: "Received: Hello World!"
```

CancelToken 是 Axios 提供的请求取消机制，其核心原理基于发布订阅模式和 Promise 控制：

1. ‌**发布订阅模式**‌：CancelToken 实例通过 subscribe 方法订阅取消消息，当外部调用 cancel 方法时会触发订阅器取消请求。
2. ‌**Promise 控制**‌：
   - source 中的 token 是一个处于 pending 状态的 Promise
   - cancel 方法是 token 的 Promise 对象的 resolve 触发器
   - 当调用 cancel 时，Promise 状态变为 resolved，触发 then 回调执行 xhr.abort()
3. ‌**内部流程**‌：
   - 创建 CancelToken 时会传入一个 executor 函数
   - executor 接收 cancel 函数作为参数
   - 调用 cancel 后，Axios 会检测到并取消对应请求

## 4. **工厂模式 (Factory Pattern)**

- **用途**：将对象的创建逻辑封装起来，客户端无需关心具体实现。
- **应用场景**：
  - 动态创建组件（如根据条件渲染不同的UI组件）。
  - 创建复杂对象（如表单字段生成器）。

```
class Button {
  render() {
    return "<button>Button</button>";
  }
}

class IconButton {
  render() {
    return "<button><i class='icon'></i>Button</button>";
  }
}

class ButtonFactory {
  createButton(type) {
    if (type === "icon") {
      return new IconButton();
    }
    return new Button();
  }
}

const factory = new ButtonFactory();
const button = factory.createButton("icon");
console.log(button.render());
```

## 5. **策略模式 (Strategy Pattern)**

- **用途**：定义一系列算法，并将它们封装起来，使它们可以互相替换。
- **应用场景**：
  - 表单验证（不同字段使用不同的验证规则）。
  - 支付方式选择（不同支付方式对应不同策略）。

## 6. **代理模式 (Proxy Pattern)**

- **用途**：为对象提供一个代理，以控制对它的访问。
- **应用场景**：
  - 图片懒加载（代理对象控制图片的实际加载）。
  - API请求拦截（如Axios的拦截器）。

## 7. **装饰器模式 (Decorator Pattern)**

- **用途**：动态地为对象添加功能，而不改变其结构。
- **应用场景**：
  - 高阶组件（HOC）在React中的应用。
  - 扩展组件功能（如添加日志、权限校验）。 

## 8. **模块模式 (Module Pattern)**

- **用途**：将代码组织成独立的模块，避免全局命名空间污染。
- **应用场景**：
  - 封装工具函数。
  - 实现私有变量和方法。

## 设计类题目

### "请设计一个可配置的 Dialog 弹窗组件，要求支持： 尺寸/颜色自定义 自动关闭倒计时 手动关闭按钮 含输入框及校验规则 支持扩展功能"

1. **策略模式**处理关闭逻辑：将自动关闭倒计时和手动关闭抽象为独立策略
2. **装饰器模式**扩展功能：通过@Validate装饰器处理输入校验
3. **观察者模式**管理实例：通过事件总线处理多弹窗层级关系
4. **响应式尺寸方案**：支持预设尺寸和自定义像素数组

# 准备

调研tab多页签兼容策略，参与微前端项目中tab多页签的迁移开发并上线

参与列表页升级需求，优化组件与页面的适配交互，累积升级20+页面并上线

参与新页面开发需求，

![img](https://uploadfiles.nowcoder.com/images/20250219/347676512_1739967778771/E8DA6D42804AC338B2ACD62B6F97DE8B)





- 准备过程

  **1. 项目部分** 我觉得社招应该主要问工作经历，所以我几乎是 all in 项目。准备方式很简单：

  - 把简历丢给大模型让它问我问题
  - 提前准备好各种回答
  - 特别注意从用户角度去讲，比如：
    - 我们是干啥的（核心业务）
    - 解决什么问题
    - 用户需要啥，我们怎么满足的
  - 技术问题反而不用太担心，毕竟是自己做的项目，肯定比面试官熟啊 😄

  **2. 算法准备** 二面有道算法题，力扣是 hard，但是我很久没刷题了，没啥印象。被面试官说"这道题应该比较基础？"... 

  于是我开始刷 Hot100，刷了三遍：

  第一遍（4天）：

  - 按顺序全刷一遍
  - 记录下哪些题10分钟搞不定
  - 发现好多啊，差不多50道 😅

  第二遍（2天）：

  - 专门刷那50道题
  - 要求提高到5分钟内解决
  - 还是有30多道搞不定

  最后一遍（1天）：

  - 死磕那30道题
  - 目标是10分钟内必须搞定
  - 效果还不错，三面的时候做题贼快，面试官还加了一道 😎

  **3. 八股文准备** 这个比较简单：

  - 看看简历上写了啥技术栈
  - 把底层原理背一背
  - 让大模型出题考我
  - 感觉答得通就行

  一点小总结

  - 项目得讲人话，让面试官听得懂
  - 算法就是刷，短期突击就是得靠高强度重复
  - 八股文该背还得背
